// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.4.2 (swiftlang-1205.0.28.2 clang-1205.0.19.57)
// swift-module-flags: -target arm64-apple-ios10.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name HHSDKVideo
import AVFoundation
import AVKit
import Accelerate
import CoreGraphics
import CoreLocation
import CoreMotion
import CoreTelephony
import Darwin
import Dispatch
import Foundation
@_exported import HHSDKVideo
import ImageIO
import LocalAuthentication
import MobileCoreServices
import ObjectiveC
import Photos
import PhotosUI
import Security
import SecurityKit
import Swift
import SystemConfiguration
import UIKit
import UserNotifications
import WebKit
public protocol AEAD {
  static var kLen: Swift.Int { get }
  static var ivRange: Swift.Range<Swift.Int> { get }
}
@_hasMissingDesignatedInitializers final public class AEADChaCha20Poly1305 : HHSDKVideo.AEAD {
  public static let kLen: Swift.Int
  public static var ivRange: Swift.Range<Swift.Int>
  public static func encrypt(_ plainText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>) throws -> (cipherText: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>)
  public static func decrypt(_ cipherText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>) throws -> (plainText: Swift.Array<Swift.UInt8>, success: Swift.Bool)
  @objc deinit
}
final public class AES {
  public enum Error : Swift.Error {
    case invalidKeySize
    case dataPaddingRequired
    case invalidData
    public static func == (a: HHSDKVideo.AES.Error, b: HHSDKVideo.AES.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant : Swift.Int {
    case aes128, aes192, aes256
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  final public let variant: HHSDKVideo.AES.Variant
  public init(key: Swift.Array<Swift.UInt8>, blockMode: HHSDKVideo.BlockMode, padding: HHSDKVideo.Padding = .pkcs7) throws
  @objc deinit
}
extension AES : HHSDKVideo.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension AES {
  convenience public init(key: Swift.String, iv: Swift.String, padding: HHSDKVideo.Padding = .pkcs7) throws
}
extension AES : HHSDKVideo.Cryptors {
  final public func makeEncryptor() throws -> HHSDKVideo.Cryptor & HHSDKVideo.Updatable
  final public func makeDecryptor() throws -> HHSDKVideo.Cryptor & HHSDKVideo.Updatable
}
extension Array where Element == Swift.UInt8 {
  public init(hex: Swift.String)
  public func toHexString() -> Swift.String
}
extension Array where Element == Swift.UInt8 {
  @available(*, deprecated)
  public func chunks(size chunksize: Swift.Int) -> Swift.Array<Swift.Array<Element>>
  public func md5() -> [Element]
  public func sha1() -> [Element]
  public func sha224() -> [Element]
  public func sha256() -> [Element]
  public func sha384() -> [Element]
  public func sha512() -> [Element]
  public func sha2(_ variant: HHSDKVideo.SHA2.Variant) -> [Element]
  public func sha3(_ variant: HHSDKVideo.SHA3.Variant) -> [Element]
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.UInt16
  public func encrypt(cipher: HHSDKVideo.Cipher) throws -> [Element]
  public func decrypt(cipher: HHSDKVideo.Cipher) throws -> [Element]
  public func authenticate<A>(with authenticator: A) throws -> [Element] where A : HHSDKVideo.CryptoAuthenticator
}
extension Array where Element == Swift.UInt8 {
  public func toBase64() -> Swift.String?
  public init(base64: Swift.String)
}
public protocol CryptoAuthenticator {
  func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
public enum Bit : Swift.Int {
  case zero
  case one
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class BlockDecryptor : HHSDKVideo.Cryptor, HHSDKVideo.Updatable {
  public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
  public func seek(to position: Swift.Int) throws
  @objc deinit
}
public typealias CipherOperationOnBlock = (Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
public protocol BlockMode {
  var options: HHSDKVideo.BlockModeOption { get }
  func worker(blockSize: Swift.Int, cipherOperation: @escaping HHSDKVideo.CipherOperationOnBlock, encryptionOperation: @escaping HHSDKVideo.CipherOperationOnBlock) throws -> HHSDKVideo.CipherModeWorker
}
public struct BlockModeOption : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  public typealias ArrayLiteralElement = HHSDKVideo.BlockModeOption
  public typealias Element = HHSDKVideo.BlockModeOption
  public typealias RawValue = Swift.Int
}
final public class Blowfish {
  public enum Error : Swift.Error {
    case dataPaddingRequired
    case invalidKeyOrInitializationVector
    case invalidInitializationVector
    case invalidBlockMode
    public static func == (a: HHSDKVideo.Blowfish.Error, b: HHSDKVideo.Blowfish.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, blockMode: HHSDKVideo.BlockMode = CBC(iv: Array<UInt8>(repeating: 0, count: Blowfish.blockSize)), padding: HHSDKVideo.Padding) throws
  @objc deinit
}
extension Blowfish : HHSDKVideo.Cipher {
  final public func encrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
  final public func decrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
}
extension Blowfish {
  convenience public init(key: Swift.String, iv: Swift.String, padding: HHSDKVideo.Padding = .pkcs7) throws
}
@_hasMissingDesignatedInitializers public class BusyPics {
  public static let `default`: HHSDKVideo.BusyPics
  public func cacheImgs()
  public func getImgs() -> [Foundation.URL?]
  @objc deinit
}
public struct CallDoctorModel : HHSDKVideo.Mappable {
  public var doctor: HHSDKVideo.HHDoctorModel?
  public var order: HHSDKVideo.OrderModel?
  public var appoint: Swift.String?
  public var pushFlowUrl: Swift.String?
  public var realPatientUuid: Swift.Int?
  public var payUrl: Swift.String?
  public init?(map: HHSDKVideo.Map)
  public mutating func mapping(map: HHSDKVideo.Map)
}
public struct CBC : HHSDKVideo.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: HHSDKVideo.CBC.Error, b: HHSDKVideo.CBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: HHSDKVideo.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping HHSDKVideo.CipherOperationOnBlock, encryptionOperation: @escaping HHSDKVideo.CipherOperationOnBlock) throws -> HHSDKVideo.CipherModeWorker
}
@_inheritsConvenienceInitializers final public class CBCMAC : HHSDKVideo.CMAC {
  override final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  override public init(key: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
public struct CCM {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case invalidParameter
    case fail
    public static func == (a: HHSDKVideo.CCM.Error, b: HHSDKVideo.CCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: HHSDKVideo.BlockModeOption
  public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping HHSDKVideo.CipherOperationOnBlock, encryptionOperation: @escaping HHSDKVideo.CipherOperationOnBlock) throws -> HHSDKVideo.CipherModeWorker
}
public struct CFB : HHSDKVideo.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: HHSDKVideo.CFB.Error, b: HHSDKVideo.CFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: HHSDKVideo.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping HHSDKVideo.CipherOperationOnBlock, encryptionOperation: @escaping HHSDKVideo.CipherOperationOnBlock) throws -> HHSDKVideo.CipherModeWorker
}
final public class ChaCha20 {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    case notSupported
    public static func == (a: HHSDKVideo.ChaCha20.Error, b: HHSDKVideo.ChaCha20.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, iv nonce: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
extension ChaCha20 : HHSDKVideo.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension ChaCha20 {
  public struct ChaChaEncryptor : HHSDKVideo.Cryptor, HHSDKVideo.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension ChaCha20 {
  public struct ChaChaDecryptor : HHSDKVideo.Cryptor, HHSDKVideo.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = true) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension ChaCha20 : HHSDKVideo.Cryptors {
  final public func makeEncryptor() -> HHSDKVideo.Cryptor & HHSDKVideo.Updatable
  final public func makeDecryptor() -> HHSDKVideo.Cryptor & HHSDKVideo.Updatable
}
extension ChaCha20 {
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
public struct ChatApi {
}
@_hasMissingDesignatedInitializers final public class Checksum {
  @objc deinit
}
extension Checksum {
  public static func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public static func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public static func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16
}
public enum CipherError : Swift.Error {
  case encrypt
  case decrypt
  public static func == (a: HHSDKVideo.CipherError, b: HHSDKVideo.CipherError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Cipher : AnyObject {
  var keySize: Swift.Int { get }
  func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension Cipher {
  public func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
public protocol CipherModeWorker {
  var cipherOperation: HHSDKVideo.CipherOperationOnBlock { get }
  var additionalBufferSize: Swift.Int { get }
  mutating func encrypt(block plaintext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  mutating func decrypt(block ciphertext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
}
public protocol BlockModeWorker : HHSDKVideo.CipherModeWorker {
  var blockSize: Swift.Int { get }
}
public protocol CounterModeWorker : HHSDKVideo.CipherModeWorker {
  associatedtype Counter
  var counter: Self.Counter { get set }
}
public protocol SeekableModeWorker : HHSDKVideo.CipherModeWorker {
  mutating func seek(to position: Swift.Int) throws
}
public protocol StreamModeWorker : HHSDKVideo.CipherModeWorker {
}
public protocol FinalizingEncryptModeWorker : HHSDKVideo.CipherModeWorker {
  mutating func finalize(encrypt ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
public protocol FinalizingDecryptModeWorker : HHSDKVideo.CipherModeWorker {
  @discardableResult
  mutating func willDecryptLast(bytes ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func didDecryptLast(bytes plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func finalize(decrypt plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
public class CMAC : HHSDKVideo.CryptoAuthenticator {
  public enum Error : Swift.Error {
    case wrongKeyLength
    public static func == (a: HHSDKVideo.CMAC.Error, b: HHSDKVideo.CMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(key: Swift.Array<Swift.UInt8>) throws
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>, cipher: HHSDKVideo.Cipher) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
open class CodableTransform<T> : HHSDKVideo.TransformType where T : Swift.Decodable, T : Swift.Encodable {
  public typealias Object = T
  public typealias JSON = Any
  public init()
  open func transformFromJSON(_ value: Any?) -> HHSDKVideo.CodableTransform<T>.Object?
  open func transformToJSON(_ value: T?) -> HHSDKVideo.CodableTransform<T>.JSON?
  @objc deinit
}
public struct CommentApi {
}
@objc @_inheritsConvenienceInitializers public class CommentBaseVC : UIKit.UIViewController {
  @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class CommentVC : HHSDKVideo.CommentBaseVC {
  @objc override dynamic public func viewDidLoad()
  public static func show(_ orderId: Swift.String, docId: Swift.String, uuid: Swift.Int?, type: HHSDKVideo.HHCallType?, _ model: HHSDKVideo.HHGetQuesetionModel?)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public protocol Cryptor {
  mutating func seek(to: Swift.Int) throws
}
public protocol Cryptors : AnyObject {
  func makeEncryptor() throws -> HHSDKVideo.Cryptor & HHSDKVideo.Updatable
  func makeDecryptor() throws -> HHSDKVideo.Cryptor & HHSDKVideo.Updatable
  static func randomIV(_ blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
}
extension Cryptors {
  public static func randomIV(_ count: Swift.Int) -> Swift.Array<Swift.UInt8>
}
public struct CTR {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: HHSDKVideo.CTR.Error, b: HHSDKVideo.CTR.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: HHSDKVideo.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>, counter: Swift.Int = 0)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping HHSDKVideo.CipherOperationOnBlock, encryptionOperation: @escaping HHSDKVideo.CipherOperationOnBlock) throws -> HHSDKVideo.CipherModeWorker
}
open class CustomDateFormatTransform : HHSDKVideo.DateFormatterTransform {
  public init(formatString: Swift.String)
  override public init(dateFormatter: Foundation.DateFormatter)
  @objc deinit
}
extension Data {
  public func checksum() -> Swift.UInt16
  public func md5() -> Foundation.Data
  public func sha1() -> Foundation.Data
  public func sha224() -> Foundation.Data
  public func sha256() -> Foundation.Data
  public func sha384() -> Foundation.Data
  public func sha512() -> Foundation.Data
  public func sha3(_ variant: HHSDKVideo.SHA3.Variant) -> Foundation.Data
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc16(seed: Swift.UInt16? = nil) -> Foundation.Data
  public func encrypt(cipher: HHSDKVideo.Cipher) throws -> Foundation.Data
  public func decrypt(cipher: HHSDKVideo.Cipher) throws -> Foundation.Data
  public func authenticate(with authenticator: HHSDKVideo.CryptoAuthenticator) throws -> Foundation.Data
}
extension Data {
  public init(hex: Swift.String)
  public var bytes: Swift.Array<Swift.UInt8> {
    get
  }
  public func toHexString() -> Swift.String
}
open class DataTransform : HHSDKVideo.TransformType {
  public typealias Object = Foundation.Data
  public typealias JSON = Swift.String
  public init()
  open func transformFromJSON(_ value: Any?) -> Foundation.Data?
  open func transformToJSON(_ value: Foundation.Data?) -> Swift.String?
  @objc deinit
}
open class DateFormatterTransform : HHSDKVideo.TransformType {
  public typealias Object = Foundation.Date
  public typealias JSON = Swift.String
  final public let dateFormatter: Foundation.DateFormatter
  public init(dateFormatter: Foundation.DateFormatter)
  open func transformFromJSON(_ value: Any?) -> Foundation.Date?
  open func transformToJSON(_ value: Foundation.Date?) -> Swift.String?
  @objc deinit
}
open class DateTransform : HHSDKVideo.TransformType {
  public typealias Object = Foundation.Date
  public typealias JSON = Swift.Double
  public enum Unit : Foundation.TimeInterval {
    case seconds
    case milliseconds
    public init?(rawValue: Foundation.TimeInterval)
    public typealias RawValue = Foundation.TimeInterval
    public var rawValue: Foundation.TimeInterval {
      get
    }
  }
  public init(unit: HHSDKVideo.DateTransform.Unit = .seconds)
  open func transformFromJSON(_ value: Any?) -> Foundation.Date?
  open func transformToJSON(_ value: Foundation.Date?) -> Swift.Double?
  @objc deinit
}
public struct DGElasticPullToRefreshConstants {
  public static var WaveMaxHeight: CoreGraphics.CGFloat
  public static var MinOffsetToPull: CoreGraphics.CGFloat
  public static var LoadingContentInset: CoreGraphics.CGFloat
  public static var LoadingViewSize: CoreGraphics.CGFloat
}
extension NSObject {
  public func dg_addObserver(_ observer: ObjectiveC.NSObject, forKeyPath keyPath: Swift.String)
  public func dg_removeObserver(_ observer: ObjectiveC.NSObject, forKeyPath keyPath: Swift.String)
}
extension UIScrollView {
  public func dg_addPullToRefreshWithActionHandler(_ actionHandler: @escaping () -> Swift.Void, loadingView: HHSDKVideo.DGElasticPullToRefreshLoadingView?)
  public func dg_removePullToRefresh()
  public func dg_setPullToRefreshBackgroundColor(_ color: UIKit.UIColor)
  public func dg_setPullToRefreshFillColor(_ color: UIKit.UIColor)
  public func dg_stopLoading()
  public func dg_startLoading()
}
extension UIView {
  public func dg_center(_ usePresentationLayerIfPossible: Swift.Bool) -> CoreGraphics.CGPoint
}
extension UIPanGestureRecognizer {
  public func dg_resign()
}
extension UIGestureRecognizer.State {
  public func dg_isAnyOf(_ values: [UIKit.UIGestureRecognizer.State]) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers open class DGElasticPullToRefreshLoadingView : UIKit.UIView {
  @objc dynamic public init()
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  open func setPullProgress(_ progress: CoreGraphics.CGFloat)
  open func startAnimating()
  open func stopLoading()
  @objc deinit
}
extension CGFloat {
  public func toRadians() -> CoreGraphics.CGFloat
  public func toDegrees() -> CoreGraphics.CGFloat
}
@objc open class DGElasticPullToRefreshLoadingViewCircle : HHSDKVideo.DGElasticPullToRefreshLoadingView {
  @objc override dynamic public init()
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  override open func setPullProgress(_ progress: CoreGraphics.CGFloat)
  override open func startAnimating()
  override open func stopLoading()
  @objc override dynamic open func tintColorDidChange()
  @objc override dynamic open func layoutSubviews()
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
public enum DGElasticPullToRefreshState : Swift.Int {
  case stopped
  case dragging
  case animatingBounce
  case loading
  case animatingToStopped
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc @_hasMissingDesignatedInitializers open class DGElasticPullToRefreshView : UIKit.UIView {
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
  @objc override dynamic open func observeValue(forKeyPath keyPath: Swift.String?, of object: Any?, change: [Foundation.NSKeyValueChangeKey : Any]?, context: Swift.UnsafeMutableRawPointer?)
  @objc override dynamic open func layoutSubviews()
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
}
public struct DictionaryTransform<Key, Value> : HHSDKVideo.TransformType where Key : Swift.Hashable, Key : Swift.RawRepresentable, Value : HHSDKVideo.Mappable, Key.RawValue == Swift.String {
  public init()
  public func transformFromJSON(_ value: Any?) -> [Key : Value]?
  public func transformToJSON(_ value: [Key : Value]?) -> Any?
  public typealias JSON = Any
  public typealias Object = Swift.Dictionary<Key, Value>
}
@available(*, renamed: "Digest")
public typealias Hash = HHSDKVideo.Digest
public struct Digest {
  public static func md5(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha1(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha224(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha256(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha384(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha512(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha2(_ bytes: Swift.Array<Swift.UInt8>, variant: HHSDKVideo.SHA2.Variant) -> Swift.Array<Swift.UInt8>
  public static func sha3(_ bytes: Swift.Array<Swift.UInt8>, variant: HHSDKVideo.SHA3.Variant) -> Swift.Array<Swift.UInt8>
}
public struct ECB : HHSDKVideo.BlockMode {
  public let options: HHSDKVideo.BlockModeOption
  public init()
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping HHSDKVideo.CipherOperationOnBlock, encryptionOperation: @escaping HHSDKVideo.CipherOperationOnBlock) throws -> HHSDKVideo.CipherModeWorker
}
@objc @_inheritsConvenienceInitializers public class EKAccessoryNoteMessageView : UIKit.UIView {
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public struct EKAlertMessage {
  public enum ImagePosition {
    case top
    case left
    public static func == (a: HHSDKVideo.EKAlertMessage.ImagePosition, b: HHSDKVideo.EKAlertMessage.ImagePosition) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let imagePosition: HHSDKVideo.EKAlertMessage.ImagePosition
  public let simpleMessage: HHSDKVideo.EKSimpleMessage
  public let buttonBarContent: HHSDKVideo.EKProperty.ButtonBarContent
  public init(simpleMessage: HHSDKVideo.EKSimpleMessage, imagePosition: HHSDKVideo.EKAlertMessage.ImagePosition = .top, buttonBarContent: HHSDKVideo.EKProperty.ButtonBarContent)
}
@objc @_hasMissingDesignatedInitializers final public class EKAlertMessageView : HHSDKVideo.EKSimpleMessageView {
  public init(with message: HHSDKVideo.EKAlertMessage)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
public struct EKAttributes {
  public var name: Swift.String?
  public var windowLevel: HHSDKVideo.EKAttributes.WindowLevel
  public var position: HHSDKVideo.EKAttributes.Position
  public var precedence: HHSDKVideo.EKAttributes.Precedence
  public var displayDuration: Swift.Double
  public var positionConstraints: HHSDKVideo.EKAttributes.PositionConstraints
  public var screenInteraction: HHSDKVideo.EKAttributes.UserInteraction
  public var entryInteraction: HHSDKVideo.EKAttributes.UserInteraction
  public var scroll: HHSDKVideo.EKAttributes.Scroll
  public var hapticFeedbackType: HHSDKVideo.EKAttributes.NotificationHapticFeedback
  public var lifecycleEvents: HHSDKVideo.EKAttributes.LifecycleEvents
  public var displayMode: HHSDKVideo.EKAttributes.DisplayMode
  public var entryBackground: HHSDKVideo.EKAttributes.BackgroundStyle
  public var screenBackground: HHSDKVideo.EKAttributes.BackgroundStyle
  public var shadow: HHSDKVideo.EKAttributes.Shadow
  public var roundCorners: HHSDKVideo.EKAttributes.RoundCorners
  public var border: HHSDKVideo.EKAttributes.Border
  public var statusBar: HHSDKVideo.EKAttributes.StatusBar
  public var entranceAnimation: HHSDKVideo.EKAttributes.Animation
  public var exitAnimation: HHSDKVideo.EKAttributes.Animation
  public var popBehavior: HHSDKVideo.EKAttributes.PopBehavior {
    get
    set
  }
  public init()
}
extension EKAttributes {
  public struct Animation : Swift.Equatable {
    public struct Spring : Swift.Equatable {
      public var damping: CoreGraphics.CGFloat
      public var initialVelocity: CoreGraphics.CGFloat
      public init(damping: CoreGraphics.CGFloat, initialVelocity: CoreGraphics.CGFloat)
      public static func == (a: HHSDKVideo.EKAttributes.Animation.Spring, b: HHSDKVideo.EKAttributes.Animation.Spring) -> Swift.Bool
    }
    public struct RangeAnimation : Swift.Equatable {
      public var duration: Foundation.TimeInterval
      public var delay: Foundation.TimeInterval
      public var start: CoreGraphics.CGFloat
      public var end: CoreGraphics.CGFloat
      public var spring: HHSDKVideo.EKAttributes.Animation.Spring?
      public init(from start: CoreGraphics.CGFloat, to end: CoreGraphics.CGFloat, duration: Foundation.TimeInterval, delay: Foundation.TimeInterval = 0, spring: HHSDKVideo.EKAttributes.Animation.Spring? = nil)
      public static func == (a: HHSDKVideo.EKAttributes.Animation.RangeAnimation, b: HHSDKVideo.EKAttributes.Animation.RangeAnimation) -> Swift.Bool
    }
    public struct Translate : Swift.Equatable {
      public enum AnchorPosition : Swift.Equatable {
        case top
        case bottom
        case automatic
        public func hash(into hasher: inout Swift.Hasher)
        public static func == (a: HHSDKVideo.EKAttributes.Animation.Translate.AnchorPosition, b: HHSDKVideo.EKAttributes.Animation.Translate.AnchorPosition) -> Swift.Bool
        public var hashValue: Swift.Int {
          get
        }
      }
      public var duration: Foundation.TimeInterval
      public var delay: Foundation.TimeInterval
      public var anchorPosition: HHSDKVideo.EKAttributes.Animation.Translate.AnchorPosition
      public var spring: HHSDKVideo.EKAttributes.Animation.Spring?
      public init(duration: Foundation.TimeInterval, anchorPosition: HHSDKVideo.EKAttributes.Animation.Translate.AnchorPosition = .automatic, delay: Foundation.TimeInterval = 0, spring: HHSDKVideo.EKAttributes.Animation.Spring? = nil)
      public static func == (a: HHSDKVideo.EKAttributes.Animation.Translate, b: HHSDKVideo.EKAttributes.Animation.Translate) -> Swift.Bool
    }
    public var translate: HHSDKVideo.EKAttributes.Animation.Translate?
    public var scale: HHSDKVideo.EKAttributes.Animation.RangeAnimation?
    public var fade: HHSDKVideo.EKAttributes.Animation.RangeAnimation?
    public var containsTranslation: Swift.Bool {
      get
    }
    public var containsScale: Swift.Bool {
      get
    }
    public var containsFade: Swift.Bool {
      get
    }
    public var containsAnimation: Swift.Bool {
      get
    }
    public var maxDelay: Foundation.TimeInterval {
      get
    }
    public var maxDuration: Foundation.TimeInterval {
      get
    }
    public var totalDuration: Foundation.TimeInterval {
      get
    }
    public static var translation: HHSDKVideo.EKAttributes.Animation {
      get
    }
    public static var none: HHSDKVideo.EKAttributes.Animation {
      get
    }
    public init(translate: HHSDKVideo.EKAttributes.Animation.Translate? = nil, scale: HHSDKVideo.EKAttributes.Animation.RangeAnimation? = nil, fade: HHSDKVideo.EKAttributes.Animation.RangeAnimation? = nil)
    public static func == (a: HHSDKVideo.EKAttributes.Animation, b: HHSDKVideo.EKAttributes.Animation) -> Swift.Bool
  }
}
extension EKAttributes {
  public enum BackgroundStyle : Swift.Equatable {
    public struct BlurStyle : Swift.Equatable {
      public static var extra: HHSDKVideo.EKAttributes.BackgroundStyle.BlurStyle {
        get
      }
      public static var standard: HHSDKVideo.EKAttributes.BackgroundStyle.BlurStyle {
        get
      }
      @available(iOS 10.0, *)
      public static var prominent: HHSDKVideo.EKAttributes.BackgroundStyle.BlurStyle {
        get
      }
      public static var dark: HHSDKVideo.EKAttributes.BackgroundStyle.BlurStyle {
        get
      }
      public init(style: UIKit.UIBlurEffect.Style)
      public init(light: UIKit.UIBlurEffect.Style, dark: UIKit.UIBlurEffect.Style)
      public func blurStyle(for traits: UIKit.UITraitCollection, mode: HHSDKVideo.EKAttributes.DisplayMode) -> UIKit.UIBlurEffect.Style
      public func blurEffect(for traits: UIKit.UITraitCollection, mode: HHSDKVideo.EKAttributes.DisplayMode) -> UIKit.UIBlurEffect
      public static func == (a: HHSDKVideo.EKAttributes.BackgroundStyle.BlurStyle, b: HHSDKVideo.EKAttributes.BackgroundStyle.BlurStyle) -> Swift.Bool
    }
    public struct Gradient {
      public var colors: [HHSDKVideo.EKColor]
      public var startPoint: CoreGraphics.CGPoint
      public var endPoint: CoreGraphics.CGPoint
      public init(colors: [HHSDKVideo.EKColor], startPoint: CoreGraphics.CGPoint, endPoint: CoreGraphics.CGPoint)
    }
    case visualEffect(style: HHSDKVideo.EKAttributes.BackgroundStyle.BlurStyle)
    case color(color: HHSDKVideo.EKColor)
    case gradient(gradient: HHSDKVideo.EKAttributes.BackgroundStyle.Gradient)
    case image(image: UIKit.UIImage)
    case clear
    public static func == (lhs: HHSDKVideo.EKAttributes.BackgroundStyle, rhs: HHSDKVideo.EKAttributes.BackgroundStyle) -> Swift.Bool
  }
}
extension EKAttributes {
  public enum DisplayMode {
    case inferred
    case light
    case dark
    public static func == (a: HHSDKVideo.EKAttributes.DisplayMode, b: HHSDKVideo.EKAttributes.DisplayMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension EKAttributes {
  public typealias DisplayDuration = Foundation.TimeInterval
}
extension EKAttributes {
  public enum RoundCorners {
    case none
    case all(radius: CoreGraphics.CGFloat)
    case top(radius: CoreGraphics.CGFloat)
    case bottom(radius: CoreGraphics.CGFloat)
  }
  public enum Border {
    case none
    case value(color: UIKit.UIColor, width: CoreGraphics.CGFloat)
  }
}
extension EKAttributes {
  public enum NotificationHapticFeedback {
    case success
    case warning
    case error
    case none
    public static func == (a: HHSDKVideo.EKAttributes.NotificationHapticFeedback, b: HHSDKVideo.EKAttributes.NotificationHapticFeedback) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension EKAttributes {
  public struct LifecycleEvents {
    public typealias Event = () -> Swift.Void
    public var willAppear: HHSDKVideo.EKAttributes.LifecycleEvents.Event?
    public var didAppear: HHSDKVideo.EKAttributes.LifecycleEvents.Event?
    public var willDisappear: HHSDKVideo.EKAttributes.LifecycleEvents.Event?
    public var didDisappear: HHSDKVideo.EKAttributes.LifecycleEvents.Event?
    public init(willAppear: HHSDKVideo.EKAttributes.LifecycleEvents.Event? = nil, didAppear: HHSDKVideo.EKAttributes.LifecycleEvents.Event? = nil, willDisappear: HHSDKVideo.EKAttributes.LifecycleEvents.Event? = nil, didDisappear: HHSDKVideo.EKAttributes.LifecycleEvents.Event? = nil)
  }
}
extension EKAttributes {
  public enum PopBehavior {
    case overridden
    case animated(animation: HHSDKVideo.EKAttributes.Animation)
    public var isOverriden: Swift.Bool {
      get
    }
  }
}
extension EKAttributes {
  public enum Position {
    case top
    case bottom
    case center
    public var isTop: Swift.Bool {
      get
    }
    public var isCenter: Swift.Bool {
      get
    }
    public var isBottom: Swift.Bool {
      get
    }
    public static func == (a: HHSDKVideo.EKAttributes.Position, b: HHSDKVideo.EKAttributes.Position) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension EKAttributes {
  public struct PositionConstraints {
    public enum SafeArea {
      case overridden
      case empty(fillSafeArea: Swift.Bool)
      public var isOverridden: Swift.Bool {
        get
      }
    }
    public enum Edge {
      case ratio(value: CoreGraphics.CGFloat)
      case offset(value: CoreGraphics.CGFloat)
      case constant(value: CoreGraphics.CGFloat)
      case intrinsic
      public static var fill: HHSDKVideo.EKAttributes.PositionConstraints.Edge {
        get
      }
    }
    public struct Size {
      public var width: HHSDKVideo.EKAttributes.PositionConstraints.Edge
      public var height: HHSDKVideo.EKAttributes.PositionConstraints.Edge
      public init(width: HHSDKVideo.EKAttributes.PositionConstraints.Edge, height: HHSDKVideo.EKAttributes.PositionConstraints.Edge)
      public static var intrinsic: HHSDKVideo.EKAttributes.PositionConstraints.Size {
        get
      }
      public static var sizeToWidth: HHSDKVideo.EKAttributes.PositionConstraints.Size {
        get
      }
      public static var screen: HHSDKVideo.EKAttributes.PositionConstraints.Size {
        get
      }
    }
    public enum KeyboardRelation {
      public struct Offset {
        public var bottom: CoreGraphics.CGFloat
        public var screenEdgeResistance: CoreGraphics.CGFloat?
        public init(bottom: CoreGraphics.CGFloat = 0, screenEdgeResistance: CoreGraphics.CGFloat? = nil)
        public static var none: HHSDKVideo.EKAttributes.PositionConstraints.KeyboardRelation.Offset {
          get
        }
      }
      case bind(offset: HHSDKVideo.EKAttributes.PositionConstraints.KeyboardRelation.Offset)
      case unbind
      public var isBound: Swift.Bool {
        get
      }
    }
    public struct Rotation {
      public enum SupportedInterfaceOrientation {
        case standard
        case all
        public static func == (a: HHSDKVideo.EKAttributes.PositionConstraints.Rotation.SupportedInterfaceOrientation, b: HHSDKVideo.EKAttributes.PositionConstraints.Rotation.SupportedInterfaceOrientation) -> Swift.Bool
        public func hash(into hasher: inout Swift.Hasher)
        public var hashValue: Swift.Int {
          get
        }
      }
      public var isEnabled: Swift.Bool
      public var supportedInterfaceOrientations: HHSDKVideo.EKAttributes.PositionConstraints.Rotation.SupportedInterfaceOrientation
      public init()
    }
    public var rotation: HHSDKVideo.EKAttributes.PositionConstraints.Rotation
    public var keyboardRelation: HHSDKVideo.EKAttributes.PositionConstraints.KeyboardRelation
    public var size: HHSDKVideo.EKAttributes.PositionConstraints.Size
    public var maxSize: HHSDKVideo.EKAttributes.PositionConstraints.Size
    public var verticalOffset: CoreGraphics.CGFloat
    public var safeArea: HHSDKVideo.EKAttributes.PositionConstraints.SafeArea
    public var hasVerticalOffset: Swift.Bool {
      get
    }
    public static var float: HHSDKVideo.EKAttributes.PositionConstraints {
      get
    }
    public static var fullWidth: HHSDKVideo.EKAttributes.PositionConstraints {
      get
    }
    public static var fullScreen: HHSDKVideo.EKAttributes.PositionConstraints {
      get
    }
    public init(verticalOffset: CoreGraphics.CGFloat = 0, size: HHSDKVideo.EKAttributes.PositionConstraints.Size = .sizeToWidth, maxSize: HHSDKVideo.EKAttributes.PositionConstraints.Size = .intrinsic)
  }
}
extension EKAttributes {
  public enum Precedence {
    public struct Priority : Swift.Hashable, Swift.Equatable, Swift.RawRepresentable, Swift.Comparable {
      public var rawValue: Swift.Int
      public var hashValue: Swift.Int {
        get
      }
      public init(_ rawValue: Swift.Int)
      public init(rawValue: Swift.Int)
      public static func == (lhs: HHSDKVideo.EKAttributes.Precedence.Priority, rhs: HHSDKVideo.EKAttributes.Precedence.Priority) -> Swift.Bool
      public static func < (lhs: HHSDKVideo.EKAttributes.Precedence.Priority, rhs: HHSDKVideo.EKAttributes.Precedence.Priority) -> Swift.Bool
      public typealias RawValue = Swift.Int
    }
    public enum QueueingHeuristic {
      public static var value: HHSDKVideo.EKAttributes.Precedence.QueueingHeuristic
      case chronological
      case priority
      public static func == (a: HHSDKVideo.EKAttributes.Precedence.QueueingHeuristic, b: HHSDKVideo.EKAttributes.Precedence.QueueingHeuristic) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    case override(priority: HHSDKVideo.EKAttributes.Precedence.Priority, dropEnqueuedEntries: Swift.Bool)
    case enqueue(priority: HHSDKVideo.EKAttributes.Precedence.Priority)
    public var priority: HHSDKVideo.EKAttributes.Precedence.Priority {
      get
      set
    }
  }
}
extension EKAttributes.Precedence.Priority {
  public static let maxRawValue: Swift.Int
  public static let highRawValue: Swift.Int
  public static let normalRawValue: Swift.Int
  public static let lowRawValue: Swift.Int
  public static let minRawValue: Swift.Int
  public static let max: HHSDKVideo.EKAttributes.Precedence.Priority
  public static let high: HHSDKVideo.EKAttributes.Precedence.Priority
  public static let normal: HHSDKVideo.EKAttributes.Precedence.Priority
  public static let low: HHSDKVideo.EKAttributes.Precedence.Priority
  public static let min: HHSDKVideo.EKAttributes.Precedence.Priority
}
extension EKAttributes {
  public static var `default`: HHSDKVideo.EKAttributes
  public static var toast: HHSDKVideo.EKAttributes {
    get
  }
  public static var float: HHSDKVideo.EKAttributes {
    get
  }
  public static var topFloat: HHSDKVideo.EKAttributes {
    get
  }
  public static var bottomFloat: HHSDKVideo.EKAttributes {
    get
  }
  public static var centerFloat: HHSDKVideo.EKAttributes {
    get
  }
  public static var bottomToast: HHSDKVideo.EKAttributes {
    get
  }
  public static var topToast: HHSDKVideo.EKAttributes {
    get
  }
  public static var topNote: HHSDKVideo.EKAttributes {
    get
  }
  public static var bottomNote: HHSDKVideo.EKAttributes {
    get
  }
  public static var statusBar: HHSDKVideo.EKAttributes {
    get
  }
}
extension EKAttributes {
  public enum Scroll {
    public struct PullbackAnimation {
      public var duration: Foundation.TimeInterval
      public var damping: CoreGraphics.CGFloat
      public var initialSpringVelocity: CoreGraphics.CGFloat
      public init(duration: Foundation.TimeInterval, damping: CoreGraphics.CGFloat, initialSpringVelocity: CoreGraphics.CGFloat)
      public static var jolt: HHSDKVideo.EKAttributes.Scroll.PullbackAnimation {
        get
      }
      public static var easeOut: HHSDKVideo.EKAttributes.Scroll.PullbackAnimation {
        get
      }
    }
    case disabled
    case edgeCrossingDisabled(swipeable: Swift.Bool)
    case enabled(swipeable: Swift.Bool, pullbackAnimation: HHSDKVideo.EKAttributes.Scroll.PullbackAnimation)
  }
}
extension EKAttributes {
  public enum Shadow {
    case none
    case active(with: HHSDKVideo.EKAttributes.Shadow.Value)
    public struct Value {
      public let radius: CoreGraphics.CGFloat
      public let opacity: Swift.Float
      public let color: HHSDKVideo.EKColor
      public let offset: CoreGraphics.CGSize
      public init(color: HHSDKVideo.EKColor = .black, opacity: Swift.Float, radius: CoreGraphics.CGFloat, offset: CoreGraphics.CGSize = .zero)
    }
  }
}
extension EKAttributes {
  public enum StatusBar {
    public typealias Appearance = (visible: Swift.Bool, style: UIKit.UIStatusBarStyle)
    case ignored
    case hidden
    case dark
    case light
    case inferred
    public var appearance: HHSDKVideo.EKAttributes.StatusBar.Appearance {
      get
    }
    public static func statusBar(by appearance: HHSDKVideo.EKAttributes.StatusBar.Appearance) -> HHSDKVideo.EKAttributes.StatusBar
    public static var currentAppearance: HHSDKVideo.EKAttributes.StatusBar.Appearance {
      get
    }
    public static var currentStatusBar: HHSDKVideo.EKAttributes.StatusBar {
      get
    }
    public static func == (a: HHSDKVideo.EKAttributes.StatusBar, b: HHSDKVideo.EKAttributes.StatusBar) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension EKAttributes {
  public struct UserInteraction {
    public typealias Action = () -> ()
    public enum Default {
      case absorbTouches
      case delayExit(by: Foundation.TimeInterval)
      case dismissEntry
      case forward
    }
    public var defaultAction: HHSDKVideo.EKAttributes.UserInteraction.Default
    public var customTapActions: [HHSDKVideo.EKAttributes.UserInteraction.Action]
    public init(defaultAction: HHSDKVideo.EKAttributes.UserInteraction.Default = .absorbTouches, customTapActions: [HHSDKVideo.EKAttributes.UserInteraction.Action] = [])
    public static var dismiss: HHSDKVideo.EKAttributes.UserInteraction {
      get
    }
    public static var forward: HHSDKVideo.EKAttributes.UserInteraction {
      get
    }
    public static var absorbTouches: HHSDKVideo.EKAttributes.UserInteraction {
      get
    }
    public static func delayExit(by delay: Foundation.TimeInterval) -> HHSDKVideo.EKAttributes.UserInteraction
  }
}
extension EKAttributes {
  public enum WindowLevel {
    case alerts
    case statusBar
    case normal
    case custom(level: UIKit.UIWindow.Level)
    public var value: UIKit.UIWindow.Level {
      get
    }
  }
}
@objc final public class EKButtonBarView : UIKit.UIView {
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  public init(with buttonBarContent: HHSDKVideo.EKProperty.ButtonBarContent)
  @objc override final public func layoutSubviews()
  final public func expand()
  final public func compress()
  @objc override final public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
public struct EKColor : Swift.Equatable {
  public var dark: UIKit.UIColor {
    get
  }
  public var light: UIKit.UIColor {
    get
  }
  public init(light: UIKit.UIColor, dark: UIKit.UIColor)
  public init(_ unified: UIKit.UIColor)
  public init(rgb: Swift.Int)
  public init(red: Swift.Int, green: Swift.Int, blue: Swift.Int)
  public func color(for traits: UIKit.UITraitCollection, mode: HHSDKVideo.EKAttributes.DisplayMode) -> UIKit.UIColor
  public static func == (a: HHSDKVideo.EKColor, b: HHSDKVideo.EKColor) -> Swift.Bool
}
extension EKColor {
  public var inverted: HHSDKVideo.EKColor {
    get
  }
  public func with(alpha: CoreGraphics.CGFloat) -> HHSDKVideo.EKColor
  public static var white: HHSDKVideo.EKColor {
    get
  }
  public static var black: HHSDKVideo.EKColor {
    get
  }
  public static var clear: HHSDKVideo.EKColor {
    get
  }
  public static var standardBackground: HHSDKVideo.EKColor {
    get
  }
  public static var standardContent: HHSDKVideo.EKColor {
    get
  }
}
@objc final public class EKFormMessageView : UIKit.UIView {
  public init(with title: HHSDKVideo.EKProperty.LabelContent, textFieldsContent: [HHSDKVideo.EKProperty.TextFieldContent], buttonContent: HHSDKVideo.EKProperty.ButtonContent)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  final public func becomeFirstResponder(with textFieldIndex: Swift.Int)
  @objc override final public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
@objc public class EKImageNoteMessageView : HHSDKVideo.EKAccessoryNoteMessageView {
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  public init(with content: HHSDKVideo.EKProperty.LabelContent, imageContent: HHSDKVideo.EKProperty.ImageContent)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
@objc public class EKMessageContentView : UIKit.UIView {
  public var titleContent: HHSDKVideo.EKProperty.LabelContent! {
    get
    set
  }
  public var subtitleContent: HHSDKVideo.EKProperty.LabelContent! {
    get
    set
  }
  public var titleAttributes: HHSDKVideo.EKProperty.LabelStyle! {
    get
    set
  }
  public var subtitleAttributes: HHSDKVideo.EKProperty.LabelStyle! {
    get
    set
  }
  public var title: Swift.String! {
    get
    set
  }
  public var subtitle: Swift.String! {
    get
    set
  }
  public var verticalMargins: CoreGraphics.CGFloat {
    get
    set
  }
  public var horizontalMargins: CoreGraphics.CGFloat {
    get
    set
  }
  public var labelsOffset: CoreGraphics.CGFloat {
    get
    set
  }
  @objc dynamic public init()
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
@objc public class EKNoteMessageView : UIKit.UIView {
  public var horizontalOffset: CoreGraphics.CGFloat {
    get
    set
  }
  public var verticalOffset: CoreGraphics.CGFloat {
    get
    set
  }
  public init(with content: HHSDKVideo.EKProperty.LabelContent)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
public struct EKNotificationMessage {
  public struct Insets {
    public var contentInsets: UIKit.UIEdgeInsets
    public var titleToDescription: CoreGraphics.CGFloat
    public static var `default`: HHSDKVideo.EKNotificationMessage.Insets
  }
  public let simpleMessage: HHSDKVideo.EKSimpleMessage
  public let auxiliary: HHSDKVideo.EKProperty.LabelContent?
  public let insets: HHSDKVideo.EKNotificationMessage.Insets
  public init(simpleMessage: HHSDKVideo.EKSimpleMessage, auxiliary: HHSDKVideo.EKProperty.LabelContent? = nil, insets: HHSDKVideo.EKNotificationMessage.Insets = .default)
}
@objc @_hasMissingDesignatedInitializers final public class EKNotificationMessageView : HHSDKVideo.EKSimpleMessageView {
  public init(with message: HHSDKVideo.EKNotificationMessage)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override final public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @objc deinit
}
public struct EKPopUpMessage {
  public typealias EKPopUpMessageAction = () -> ()
  public struct ThemeImage {
    public enum Position {
      case topToTop(offset: CoreGraphics.CGFloat)
      case centerToTop(offset: CoreGraphics.CGFloat)
    }
    public var image: HHSDKVideo.EKProperty.ImageContent
    public var position: HHSDKVideo.EKPopUpMessage.ThemeImage.Position
    public init(image: HHSDKVideo.EKProperty.ImageContent, position: HHSDKVideo.EKPopUpMessage.ThemeImage.Position = .topToTop(offset: 40))
  }
  public var themeImage: HHSDKVideo.EKPopUpMessage.ThemeImage?
  public var title: HHSDKVideo.EKProperty.LabelContent
  public var description: HHSDKVideo.EKProperty.LabelContent
  public var button: HHSDKVideo.EKProperty.ButtonContent
  public var action: HHSDKVideo.EKPopUpMessage.EKPopUpMessageAction
  public init(themeImage: HHSDKVideo.EKPopUpMessage.ThemeImage? = nil, title: HHSDKVideo.EKProperty.LabelContent, description: HHSDKVideo.EKProperty.LabelContent, button: HHSDKVideo.EKProperty.ButtonContent, action: @escaping HHSDKVideo.EKPopUpMessage.EKPopUpMessageAction)
}
@objc final public class EKPopUpMessageView : UIKit.UIView {
  public init(with message: HHSDKVideo.EKPopUpMessage)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override final public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
@objc public class EKProcessingNoteMessageView : HHSDKVideo.EKAccessoryNoteMessageView {
  public var isProcessing: Swift.Bool {
    get
    set
  }
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  public init(with content: HHSDKVideo.EKProperty.LabelContent, activityIndicator: UIKit.UIActivityIndicatorView.Style)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
public struct EKProperty {
  public struct ButtonContent {
    public typealias Action = () -> ()
    public var label: HHSDKVideo.EKProperty.LabelContent
    public var backgroundColor: HHSDKVideo.EKColor
    public var highlightedBackgroundColor: HHSDKVideo.EKColor
    public var contentEdgeInset: CoreGraphics.CGFloat
    public var displayMode: HHSDKVideo.EKAttributes.DisplayMode
    public var accessibilityIdentifier: Swift.String?
    public var action: HHSDKVideo.EKProperty.ButtonContent.Action?
    public init(label: HHSDKVideo.EKProperty.LabelContent, backgroundColor: HHSDKVideo.EKColor, highlightedBackgroundColor: HHSDKVideo.EKColor, contentEdgeInset: CoreGraphics.CGFloat = 5, displayMode: HHSDKVideo.EKAttributes.DisplayMode = .inferred, accessibilityIdentifier: Swift.String? = nil, action: @escaping HHSDKVideo.EKProperty.ButtonContent.Action = {})
    public func backgroundColor(for traitCollection: UIKit.UITraitCollection) -> UIKit.UIColor
    public func highlightedBackgroundColor(for traitCollection: UIKit.UITraitCollection) -> UIKit.UIColor
    public func highlighedLabelColor(for traitCollection: UIKit.UITraitCollection) -> UIKit.UIColor
  }
  public struct LabelContent {
    public var text: Swift.String
    public var style: HHSDKVideo.EKProperty.LabelStyle
    public var accessibilityIdentifier: Swift.String?
    public init(text: Swift.String, style: HHSDKVideo.EKProperty.LabelStyle, accessibilityIdentifier: Swift.String? = nil)
  }
  public struct LabelStyle {
    public var font: UIKit.UIFont
    public var color: HHSDKVideo.EKColor
    public var alignment: UIKit.NSTextAlignment
    public var numberOfLines: Swift.Int
    public var displayMode: HHSDKVideo.EKAttributes.DisplayMode
    public init(font: UIKit.UIFont, color: HHSDKVideo.EKColor, alignment: UIKit.NSTextAlignment = .left, displayMode: HHSDKVideo.EKAttributes.DisplayMode = .inferred, numberOfLines: Swift.Int = 0)
    public func color(for traitCollection: UIKit.UITraitCollection) -> UIKit.UIColor
  }
  public struct ImageContent {
    public enum TransformAnimation {
      case animate(duration: Foundation.TimeInterval, options: UIKit.UIView.AnimationOptions, transform: CoreGraphics.CGAffineTransform)
      case none
    }
    public var tint: HHSDKVideo.EKColor?
    public var images: [UIKit.UIImage]
    public var imageSequenceAnimationDuration: Foundation.TimeInterval
    public var size: CoreGraphics.CGSize?
    public var contentMode: UIKit.UIView.ContentMode
    public var makesRound: Swift.Bool
    public var animation: HHSDKVideo.EKProperty.ImageContent.TransformAnimation
    public var displayMode: HHSDKVideo.EKAttributes.DisplayMode
    public var accessibilityIdentifier: Swift.String?
    public init(imageName: Swift.String, animation: HHSDKVideo.EKProperty.ImageContent.TransformAnimation = .none, displayMode: HHSDKVideo.EKAttributes.DisplayMode = .inferred, size: CoreGraphics.CGSize? = nil, contentMode: UIKit.UIView.ContentMode = .scaleToFill, tint: HHSDKVideo.EKColor? = nil, makesRound: Swift.Bool = false, accessibilityIdentifier: Swift.String? = nil)
    public init(image: UIKit.UIImage, animation: HHSDKVideo.EKProperty.ImageContent.TransformAnimation = .none, displayMode: HHSDKVideo.EKAttributes.DisplayMode = .inferred, size: CoreGraphics.CGSize? = nil, tint: HHSDKVideo.EKColor? = nil, contentMode: UIKit.UIView.ContentMode = .scaleToFill, makesRound: Swift.Bool = false, accessibilityIdentifier: Swift.String? = nil)
    public init(images: [UIKit.UIImage], imageSequenceAnimationDuration: Foundation.TimeInterval = 1, displayMode: HHSDKVideo.EKAttributes.DisplayMode = .inferred, animation: HHSDKVideo.EKProperty.ImageContent.TransformAnimation = .none, size: CoreGraphics.CGSize? = nil, tint: HHSDKVideo.EKColor? = nil, contentMode: UIKit.UIView.ContentMode = .scaleToFill, makesRound: Swift.Bool = false, accessibilityIdentifier: Swift.String? = nil)
    public init(imagesNames: [Swift.String], imageSequenceAnimationDuration: Foundation.TimeInterval = 1, displayMode: HHSDKVideo.EKAttributes.DisplayMode = .inferred, animation: HHSDKVideo.EKProperty.ImageContent.TransformAnimation = .none, size: CoreGraphics.CGSize? = nil, tint: HHSDKVideo.EKColor? = nil, contentMode: UIKit.UIView.ContentMode = .scaleToFill, makesRound: Swift.Bool = false, accessibilityIdentifier: Swift.String? = nil)
    public static func thumb(with image: UIKit.UIImage, edgeSize: CoreGraphics.CGFloat) -> HHSDKVideo.EKProperty.ImageContent
    public static func thumb(with imageName: Swift.String, edgeSize: CoreGraphics.CGFloat) -> HHSDKVideo.EKProperty.ImageContent
    public func tintColor(for traitCollection: UIKit.UITraitCollection) -> UIKit.UIColor?
  }
  public struct TextFieldContent {
    weak public var delegate: UIKit.UITextFieldDelegate?
    public var keyboardType: UIKit.UIKeyboardType
    public var isSecure: Swift.Bool
    public var leadingImage: UIKit.UIImage!
    public var placeholder: HHSDKVideo.EKProperty.LabelContent
    public var textStyle: HHSDKVideo.EKProperty.LabelStyle
    public var tintColor: HHSDKVideo.EKColor!
    public var displayMode: HHSDKVideo.EKAttributes.DisplayMode
    public var bottomBorderColor: HHSDKVideo.EKColor
    public var accessibilityIdentifier: Swift.String?
    public var textContent: Swift.String {
      get
      set
    }
    public init(delegate: UIKit.UITextFieldDelegate? = nil, keyboardType: UIKit.UIKeyboardType = .default, placeholder: HHSDKVideo.EKProperty.LabelContent, tintColor: HHSDKVideo.EKColor? = nil, displayMode: HHSDKVideo.EKAttributes.DisplayMode = .inferred, textStyle: HHSDKVideo.EKProperty.LabelStyle, isSecure: Swift.Bool = false, leadingImage: UIKit.UIImage? = nil, bottomBorderColor: HHSDKVideo.EKColor = .clear, accessibilityIdentifier: Swift.String? = nil)
    public func tintColor(for traitCollection: UIKit.UITraitCollection) -> UIKit.UIColor?
    public func bottomBorderColor(for traitCollection: UIKit.UITraitCollection) -> UIKit.UIColor?
  }
  public struct ButtonBarContent {
    public var content: [HHSDKVideo.EKProperty.ButtonContent]
    public var separatorColor: HHSDKVideo.EKColor
    public var horizontalDistributionThreshold: Swift.Int
    public var expandAnimatedly: Swift.Bool
    public var buttonHeight: CoreGraphics.CGFloat
    public var displayMode: HHSDKVideo.EKAttributes.DisplayMode
    public init(with buttonContents: HHSDKVideo.EKProperty.ButtonContent..., separatorColor: HHSDKVideo.EKColor, horizontalDistributionThreshold: Swift.Int = 2, buttonHeight: CoreGraphics.CGFloat = 50, displayMode: HHSDKVideo.EKAttributes.DisplayMode = .inferred, expandAnimatedly: Swift.Bool)
    public init(with buttonContents: [HHSDKVideo.EKProperty.ButtonContent], separatorColor: HHSDKVideo.EKColor, horizontalDistributionThreshold: Swift.Int = 2, buttonHeight: CoreGraphics.CGFloat = 50, displayMode: HHSDKVideo.EKAttributes.DisplayMode = .inferred, expandAnimatedly: Swift.Bool)
    public func separatorColor(for traitCollection: UIKit.UITraitCollection) -> UIKit.UIColor
  }
  public struct EKRatingItemContent {
    public var title: HHSDKVideo.EKProperty.LabelContent
    public var description: HHSDKVideo.EKProperty.LabelContent
    public var unselectedImage: HHSDKVideo.EKProperty.ImageContent
    public var selectedImage: HHSDKVideo.EKProperty.ImageContent
    public var size: CoreGraphics.CGSize
    public init(title: HHSDKVideo.EKProperty.LabelContent, description: HHSDKVideo.EKProperty.LabelContent, unselectedImage: HHSDKVideo.EKProperty.ImageContent, selectedImage: HHSDKVideo.EKProperty.ImageContent, size: CoreGraphics.CGSize = CGSize(width: 50, height: 50))
  }
}
public struct EKRatingMessage {
  public typealias Selection = (Swift.Int) -> Swift.Void
  public var initialTitle: HHSDKVideo.EKProperty.LabelContent
  public var initialDescription: HHSDKVideo.EKProperty.LabelContent
  public var ratingItems: [HHSDKVideo.EKProperty.EKRatingItemContent]
  public var buttonBarContent: HHSDKVideo.EKProperty.ButtonBarContent
  public var selection: HHSDKVideo.EKRatingMessage.Selection!
  public var selectedIndex: Swift.Int? {
    get
    set
  }
  public init(initialTitle: HHSDKVideo.EKProperty.LabelContent, initialDescription: HHSDKVideo.EKProperty.LabelContent, ratingItems: [HHSDKVideo.EKProperty.EKRatingItemContent], buttonBarContent: HHSDKVideo.EKProperty.ButtonBarContent, selection: HHSDKVideo.EKRatingMessage.Selection? = nil)
}
@objc final public class EKRatingMessageView : UIKit.UIView {
  public init(with message: HHSDKVideo.EKRatingMessage)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers final public class EKRatingSymbolsContainerView : UIKit.UIView {
  final public func setup(with message: HHSDKVideo.EKRatingMessage, externalSelection: @escaping HHSDKVideo.EKRatingMessage.Selection)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc final public class EKRatingSymbolView : UIKit.UIView {
  final public var isSelected: Swift.Bool {
    get
    set
  }
  public init(unselectedImage: HHSDKVideo.EKProperty.ImageContent, selectedImage: HHSDKVideo.EKProperty.ImageContent, selection: @escaping HHSDKVideo.EKRatingMessage.Selection)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
public struct EKSimpleMessage {
  public let image: HHSDKVideo.EKProperty.ImageContent?
  public let title: HHSDKVideo.EKProperty.LabelContent
  public let description: HHSDKVideo.EKProperty.LabelContent
  public init(image: HHSDKVideo.EKProperty.ImageContent? = nil, title: HHSDKVideo.EKProperty.LabelContent, description: HHSDKVideo.EKProperty.LabelContent)
}
@objc @_hasMissingDesignatedInitializers public class EKSimpleMessageView : UIKit.UIView {
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
@objc final public class EKTextField : UIKit.UIView {
  final public var text: Swift.String {
    get
    set
  }
  public init(with content: HHSDKVideo.EKProperty.TextFieldContent)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  final public func makeFirstResponder()
  @objc override final public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
@objc public class EKXStatusBarMessageView : UIKit.UIView {
  public init(leading: HHSDKVideo.EKProperty.LabelContent, trailing: HHSDKVideo.EKProperty.LabelContent)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
public func <- <T>(left: inout T, right: HHSDKVideo.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: T, right: HHSDKVideo.Map) where T : Swift.RawRepresentable
public func <- <T>(left: inout T?, right: HHSDKVideo.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: T?, right: HHSDKVideo.Map) where T : Swift.RawRepresentable
public func <- <T>(left: inout [T], right: HHSDKVideo.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: [T], right: HHSDKVideo.Map) where T : Swift.RawRepresentable
public func <- <T>(left: inout [T]?, right: HHSDKVideo.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: [T]?, right: HHSDKVideo.Map) where T : Swift.RawRepresentable
public func <- <T>(left: inout [Swift.String : T], right: HHSDKVideo.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: [Swift.String : T], right: HHSDKVideo.Map) where T : Swift.RawRepresentable
public func <- <T>(left: inout [Swift.String : T]?, right: HHSDKVideo.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: [Swift.String : T]?, right: HHSDKVideo.Map) where T : Swift.RawRepresentable
open class EnumTransform<T> : HHSDKVideo.TransformType where T : Swift.RawRepresentable {
  public typealias Object = T
  public typealias JSON = T.RawValue
  public init()
  open func transformFromJSON(_ value: Any?) -> T?
  open func transformToJSON(_ value: T?) -> T.RawValue?
  @objc deinit
}
final public class GCM : HHSDKVideo.BlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: HHSDKVideo.GCM.Mode, b: HHSDKVideo.GCM.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: HHSDKVideo.BlockModeOption
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case fail
    public static func == (a: HHSDKVideo.GCM.Error, b: HHSDKVideo.GCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: HHSDKVideo.GCM.Mode = .detached)
  convenience public init(iv: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: HHSDKVideo.GCM.Mode = .detached)
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping HHSDKVideo.CipherOperationOnBlock, encryptionOperation: @escaping HHSDKVideo.CipherOperationOnBlock) throws -> HHSDKVideo.CipherModeWorker
  @objc deinit
}
open class HexColorTransform : HHSDKVideo.TransformType {
  public typealias Object = UIKit.UIColor
  public typealias JSON = Swift.String
  public init(prefixToJSON: Swift.Bool = false, alphaToJSON: Swift.Bool = false)
  open func transformFromJSON(_ value: Any?) -> HHSDKVideo.HexColorTransform.Object?
  open func transformToJSON(_ value: HHSDKVideo.HexColorTransform.Object?) -> HHSDKVideo.HexColorTransform.JSON?
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class HHAppProtocolCheck : ObjectiveC.NSObject {
  public static let instance: HHSDKVideo.HHAppProtocolCheck
  @objc override dynamic public init()
  public func showPrivacyDialog(content: Swift.String, userDoc: Swift.String, privateDoc: Swift.String, _ agreeBlock: ((Swift.Bool) -> Swift.Void)?)
  @objc deinit
}
extension HHAppProtocolCheck : UIKit.UITextViewDelegate {
  @objc dynamic public func textView(_ textView: UIKit.UITextView, shouldInteractWith URL: Foundation.URL, in characterRange: Foundation.NSRange, interaction: UIKit.UITextItemInteraction) -> Swift.Bool
}
extension Array {
  public subscript(safe index: Swift.Int) -> Element? {
    get
  }
}
public struct HHBaseApi {
}
@propertyWrapper public struct ApiConfig {
  public var wrappedValue: HHSDKVideo.HHBaseApi {
    get
  }
  public init(path: Swift.String, method: HHSDKVideo.HHRequestMethod = .post, hostType: HHSDKVideo.HHHostType = .normal, domain: Swift.String = HHUrl.urlForFamily(), needUserInfo: Swift.Bool = true, needEncrypt: Swift.Bool = true, needDNS: Swift.Bool = true)
}
public enum HHHostType {
  case normal
  case wmp
  case medic
  public static func == (a: HHSDKVideo.HHHostType, b: HHSDKVideo.HHHostType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias HHLoginHandler = ((Swift.String?) -> Swift.Void)
@_inheritsConvenienceInitializers @objc public class HHBaseSDK : ObjectiveC.NSObject {
  @objc public static let `default`: HHSDKVideo.HHBaseSDK
  public var dnsCallback: HHSDKVideo.HHDNSProtocal?
  @objc public func start()
  @objc public func login(userToken: Swift.String, completion: @escaping HHSDKVideo.HHLoginHandler)
  @objc public func logout(_ callback: ((Swift.String?) -> Swift.Void)? = nil)
  @objc override dynamic public init()
  @objc deinit
}
@objc public enum HHBaseCallingState : Swift.Int {
  case onStart = 0
  case waitingDoctor
  case callFreeDoctor
  case callConnect
  case didRing
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public protocol HHBaseVideoDelegate : ObjectiveC.NSObjectProtocol {
  @objc func callStateChange(_ state: HHSDKVideo.HHBaseCallingState)
  @objc optional func onStart(orderId: Swift.String?)
  @objc func callDidEstablish()
  @objc func getChatParentView(_ view: UIKit.UIView)
  @objc func callFail(code: Swift.Int, error: Swift.String)
  @objc func onFail(_ errorCode: Swift.Int, errrorStr: Swift.String?)
  @objc func onCancel()
  @objc func receivedOrder(_ orderId: Swift.String)
  @objc func callDidFinish()
  @objc func onExtensionDoctor()
  @objc func onReceive(_ callID: Swift.String)
  @objc func onResponse(_ accept: Swift.Bool)
  @objc func onLeakPermission(_ type: HHSDKVideo.HHBasePermissionType)
  @objc optional func onForceOffline()
  @objc optional func inviteFamily(_ page: Swift.String)
  @objc optional func goPayCount(_ url: Swift.String)
}
@objc public protocol HHCallDelegate : ObjectiveC.NSObjectProtocol {
  @objc optional func onCallStatus(_ error: Swift.Error?)
  @objc optional func onCallSuccess()
  @objc optional func callFinished()
}
@_inheritsConvenienceInitializers @objc public class HHCallerInfo : ObjectiveC.NSObject, HHSDKVideo.Mappable {
  public var name: Swift.String?
  public var photourl: Swift.String?
  public var uuid: Swift.Int?
  public var userToken: Swift.String?
  @objc override dynamic public init()
  required public init?(map: HHSDKVideo.Map)
  public func mapping(map: HHSDKVideo.Map)
  @objc deinit
}
public class HHCameraConfig {
  weak public var sender: UIKit.UIViewController!
  public var mediaType: HHSDKVideo.HHMediaType
  public var isGrayCam: Swift.Bool
  public var canReduce: Swift.Bool
  public var autoUpload: Swift.Bool
  public var maxCount: Swift.Int?
  public var crop: HHSDKVideo.onCropFinish?
  public var canceled: HHSDKVideo.onCanceled?
  public var allowSelectVideo: Swift.Bool
  public init()
  public func build(_ block: (inout HHSDKVideo.HHCameraConfig) -> Swift.Void) -> HHSDKVideo.HHCameraConfig
  @objc deinit
}
public let HHSDKScreenWidth: CoreGraphics.CGFloat
public let HHSDKScreenHeight: CoreGraphics.CGFloat
public let China_Flag: Swift.String
public struct HHDimens {
  public static func isPad() -> Swift.Bool
  public static func isPlus() -> Swift.Bool
}
public func HHColor(_ red: CoreGraphics.CGFloat, green: CoreGraphics.CGFloat, blue: CoreGraphics.CGFloat, alpha: CoreGraphics.CGFloat = 1.0) -> UIKit.UIColor
public func HHUISingleColor(_ value: CoreGraphics.CGFloat, alpha: CoreGraphics.CGFloat = 1.0) -> UIKit.UIColor
public func visibleWindow() -> UIKit.UIWindow?
public func imageWithColor(color: UIKit.UIColor) -> UIKit.UIImage?
public func delayFunc(_ time: Swift.Double, block: @escaping () -> Swift.Void)
public func appLanguage() -> Swift.String
public func isChina() -> Swift.Bool
@_hasMissingDesignatedInitializers public class HHDevice {
  public static func isIphoneX() -> Swift.Bool
  public static func botOffset() -> CoreGraphics.CGFloat
  public static func tOffset() -> CoreGraphics.CGFloat
  public class func isSml() -> Swift.Bool
  public class func isMid() -> Swift.Bool
  public class func isPlus() -> Swift.Bool
  public class func isX() -> Swift.Bool
  public static func iphoneType() -> Swift.String
  @objc deinit
}
public typealias HHFetchBlock = (UIKit.UIImage?, [Swift.AnyHashable : Any]?) -> Swift.Void
public typealias onCanceled = (() -> Swift.Void)
public typealias onCapFinished = (([HHSDKVideo.SDKCameraImageModel]?) -> Swift.Void)
public typealias onCropFinish = (UIKit.UIImage, Swift.String?) -> Swift.Void
public enum HHMediaType : Swift.Int {
  case cusCamera
  case sysCamera
  case cusVideo
  case sysVideo
  case photoImage
  case photoVideo
  case cusPhoto
  case sysCrop
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
open class HHDataController<T> where T : HHSDKVideo.Mappable {
  open var mData: T?
  public init()
  open func request(api: HHSDKVideo.HHBaseApi, data: HHSDKVideo.HHRequestData? = nil, result: HHSDKVideo.NetResult?)
  open func emptyRequest(api: HHSDKVideo.HHBaseApi, data: HHSDKVideo.HHRequestData? = nil, result: HHSDKVideo.NetResult?)
  open func noDataRequest(api: HHSDKVideo.HHBaseApi, data: HHSDKVideo.HHRequestData? = nil, result: HHSDKVideo.NetResult?)
  open func request<E>(api: HHSDKVideo.HHBaseApi, data: HHSDKVideo.HHRequestData? = nil, result: ((E) -> Swift.Void)?, fail: HHSDKVideo.HHNetError? = nil) where E : HHSDKVideo.Mappable
  @objc deinit
}
extension Date {
  public static func currentDate() -> Foundation.Date
}
public enum DateFormat : Swift.String {
  case Full
  case SingleDate
  case Single
  case WithoutSecond
  case WithoutYearAndSecond
  case HourMinute
  case CN_Month_Day
  case CN_Hour_Minute
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@objc @_inheritsConvenienceInitializers public class HHDateUtils : ObjectiveC.NSObject {
  public class func getDateForChinaStr() -> Swift.String
  public static func stringWithDurationFromSeconds(_ seconds: Foundation.TimeInterval) -> Swift.String
  public static func component(_ date: Foundation.Date) -> Foundation.DateComponents
  @objc override dynamic public init()
  @objc deinit
}
extension HHDateUtils {
  public class func date2String(_ date: Foundation.Date, format: Swift.String) -> Swift.String
  public class func date2String(_ date: Foundation.Date, format: HHSDKVideo.DateFormat) -> Swift.String
}
extension HHDateUtils {
  public class func string2Date(_ str: Swift.String, format: HHSDKVideo.DateFormat) -> Foundation.Date?
  public class func string2Date(_ str: Swift.String, format: Swift.String) -> Foundation.Date?
}
extension HHDateUtils {
  public static func dateStringFromNow(_ date: Swift.Int) -> Swift.String
  public static func dateStringFromInt(_ date: Swift.Int) -> Swift.String
  public static func dateYearStringFromInt(_ date: Swift.Int) -> Swift.String
}
@objc @_inheritsConvenienceInitializers open class HHDeviceManager : ObjectiveC.NSObject {
  public static func jailBrokend() -> Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
public protocol HHDNSProtocal {
  func changeHost(_ hostDomain: Swift.String) -> Swift.String
  func requestHost(_ host: Swift.String, challenge: Foundation.URLAuthenticationChallenge, completion: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
}
public typealias HHPriceInfo = (priceAttri: Foundation.NSMutableAttributedString, disPriceWidth: CoreGraphics.CGFloat?)
public struct HHDoctorModel : HHSDKVideo.Mappable {
  public init?(map: HHSDKVideo.Map)
  public var agentUuid: Swift.String?
  public var createtime: Swift.String?
  public var department: Swift.String?
  public var deptid: Swift.Int?
  public var disease: Swift.String?
  public var diseaseList: [Swift.String]?
  public var doctorid: Swift.String?
  public var expertStatus: Swift.String?
  public var expertVideoTime: Swift.String?
  public var famExpertVideoPrice: Swift.Float?
  public var famServices: Swift.Int?
  public var famprovidetypes: Swift.String?
  public var hhTitle: Swift.String?
  public var hospital: Swift.String?
  public var hospitalid: Swift.Int?
  public var introduction: Swift.String?
  public var isTest: Swift.String?
  public var login: HHSDKVideo.LoginModel?
  public var workyear: Swift.Int?
  public var name: Swift.String?
  public var photourl: Swift.String?
  public var price: Swift.Float?
  public var providetype: Swift.String?
  public var province: Swift.String?
  public var service: Swift.String?
  public var serviceTypeStatus: Swift.String?
  public var speciality: Swift.String?
  public var standardDeptid: Swift.Int?
  public var standardDeptname: Swift.String?
  public var standardid: Swift.Int?
  public var subdept: Swift.String?
  public var subdeptids: Swift.String?
  public var title: Swift.String?
  public var titleid: Swift.Int?
  public var vedioTimeList: Swift.String?
  public var videoprice: Swift.Float?
  public var rate: Swift.String?
  public var license: Swift.String?
  public init()
  public mutating func mapping(map: HHSDKVideo.Map)
  public func isJianzhi() -> Swift.Bool
  public func supportType(type: HHSDKVideo.HHConsType) -> Swift.Bool
  public func getPrice() -> HHSDKVideo.HHPriceInfo?
  public func isZhuanke() -> Swift.Bool
}
public struct LoginModel : HHSDKVideo.Mappable {
  public var actionSource: Swift.String?
  public var loginname: Swift.String?
  public var name: Swift.String?
  public var photourl: Swift.String?
  public var uuid: Swift.Int?
  public var videoToken: Swift.String?
  public var phoneno: Swift.String?
  public init?(map: HHSDKVideo.Map)
  public mutating func mapping(map: HHSDKVideo.Map)
}
public enum HHConsType : Swift.String {
  case normal
  case expert_video
  case feiDao
  case video
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct HHEmptyModel : HHSDKVideo.Mappable {
  public init()
  public init?(map: HHSDKVideo.Map)
  public mutating func mapping(map: HHSDKVideo.Map)
}
@_hasMissingDesignatedInitializers public class HHEncryptUtils {
  public static func encrypto(key: Swift.String, content: Swift.String) -> Swift.String?
  public static func decrypto(key: Swift.String, content: Swift.String) -> Swift.String?
  public static func encrypto(key: Swift.String, content: Foundation.Data) -> Foundation.Data?
  public static func decrypto(key: Swift.String, content: Foundation.Data) -> Foundation.Data?
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class HHFileCacheManager : ObjectiveC.NSObject {
  public enum HHAssetPathType {
    case image
    case video
    case sound
    case dicom
    case fb
    case other
    case dataBase
    public static func == (a: HHSDKVideo.HHFileCacheManager.HHAssetPathType, b: HHSDKVideo.HHFileCacheManager.HHAssetPathType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum HHFileFormat : Swift.String {
    case Jpg
    case Png
    case Jpeg
    case webp
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  @objc override dynamic public init()
  @objc deinit
}
extension HHFileCacheManager {
  public class func getFileFormat(_ name: Swift.String) -> HHSDKVideo.HHFileCacheManager.HHAssetPathType
  public class func createSoundFilePath(_ aPath: Swift.String) -> Swift.String
  public class func createDBPath(_ aPath: Swift.String) -> Swift.String
  public class func assetsCachePath(_ pathType: HHSDKVideo.HHFileCacheManager.HHAssetPathType) -> Swift.String
  public class func createImageFilePath(_ format: HHSDKVideo.HHFileCacheManager.HHFileFormat = .Jpg) -> Swift.String
  public class func createVideoFilePath() -> Swift.String
  public class func isWriteCache(_ path: Swift.String?, data: Foundation.Data?) -> Swift.Bool
  public class func isWriteCache(_ path: Swift.String?, image: UIKit.UIImage, quality: CoreGraphics.CGFloat = 1.0) -> Swift.Bool
  public class func getFilePath(_ name: Swift.String) -> Swift.String?
}
extension HHFileCacheManager {
  public static func saveString2File(_ string: Swift.String?, fileName: Swift.String)
  public static func stringFromFile(_ fileName: Swift.String) -> Swift.String?
}
extension FileManager {
  public func addSkipBackupAttributeToItemAtURL(_ url: Foundation.URL) -> Swift.Bool
}
public var uploadManager: HHSDKVideo.UploadQueue {
  get
}
@_hasMissingDesignatedInitializers public class UploadQueue {
  @discardableResult
  public func upload(files: [Swift.String], config: HHSDKVideo.SDKUploadConfig) -> HHSDKVideo.HHFileUploadManager
  public func cancelAll(_ finished: (() -> Swift.Void)? = nil)
  @objc deinit
}
public class HHFileUploadManager {
  public var mFileQueue: [Swift.String]
  public var config: HHSDKVideo.SDKUploadConfig!
  public var mTransFile: Swift.String?
  public var isUploading: Swift.Bool
  public init(files: [Swift.String], config: HHSDKVideo.SDKUploadConfig)
  public func uploadFile(_ file: [Swift.String])
  public func cancalFiles(_ files: [Swift.String], cancelFinish: ((Swift.String) -> Swift.Void)? = nil)
  public func cancelAll(_ finished: (() -> Swift.Void)? = nil)
  @objc deinit
}
@objc public protocol HHVideoHUDable {
  @objc func showHUD()
  @objc func dismissHUD()
  @objc func showSuccess(_ message: Swift.String?)
  @objc func showError(_ messgae: Swift.String?)
}
@objc public protocol HHIM {
  @objc func register(_ cerName: Swift.String?)
  @objc func login(_ completion: ((Swift.String?) -> Swift.Void)?)
  @objc func autoLogin(_ completion: ((Swift.String?) -> Swift.Void)?)
  @objc func logout(_ callback: ((Swift.String?) -> Swift.Void)?)
  @objc func canVideo() -> Swift.Bool
}
public struct HHInviteDocModel : HHSDKVideo.Mappable {
  public var orderId: Swift.String?
  public var channelId: Swift.UInt64?
  public var doctorId: Swift.String?
  public var imageUrl: Swift.String?
  public var signalingType: Swift.String?
  public var width: CoreGraphics.CGFloat
  public var height: CoreGraphics.CGFloat
  public init?(map: HHSDKVideo.Map)
  public init(_ info: HHSDKVideo.HHNetCallChatInfo, meetId: Swift.UInt64?)
  public func isWhiteBoard() -> Swift.Bool
  public func isMultyCall() -> Swift.Bool
  public mutating func mapping(map: HHSDKVideo.Map)
}
@objc public enum HHLogMode : Swift.Int {
  case error = 0
  case warn = 1
  case info = 2
  case debug = 3
  case verbose = 4
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public func logging(type: HHSDKVideo.HHLogMode = .info, _ tip: Swift.String)
@objc @_inheritsConvenienceInitializers open class HHMediaStatusCheckUtils : ObjectiveC.NSObject {
  open class func checkCameraAccess() -> Swift.Bool
  open class func checkCameraVideoPermission() -> Swift.Bool
  open class func checkAlbumAccess() -> Swift.Bool
  open class func checkAudioAccess() -> Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers open class HHMedicNetObserver : ObjectiveC.NSObject {
  public static let sharedInstance: HHSDKVideo.HHMedicNetObserver
  open func createReachability()
  open func currentInWifi() -> Swift.Bool
  open func haveNetWork() -> Swift.Bool
  @objc deinit
}
@_hasMissingDesignatedInitializers public class HHMedicPhotoPicker {
  public static func openCamera(config: HHSDKVideo.HHCameraConfig, capFinished: HHSDKVideo.onCapFinished? = nil)
  public static func reduceImages(paths: [Swift.String], finished: @escaping (([Swift.String]) -> Swift.Void))
  public class func changeAvatar(vc: UIKit.UIViewController, reference: UIKit.UIView? = nil, uuid: Swift.Int, imgClosure: @escaping (UIKit.UIImage) -> Swift.Void, keyClosure: @escaping (Swift.String) -> Swift.Void)
  @objc deinit
}
extension HHMedicPhotoPicker {
  public static func checkPermisstion(_ type: HHSDKVideo.HHBasePermissionType, authorized: (() -> Swift.Void)?, others: ((HHSDKVideo.HHBasePermissionType) -> Swift.Void)?)
  public static func converSize(_ size: CoreGraphics.CGSize) -> CoreGraphics.CGSize
}
extension HHMedicPhotoPicker : HHSDKVideo.HHPhotoPickerManagerDelegate {
  public func selectImage(_ selecModels: [HHSDKVideo.HHPhotoPickerModel]?)
  public func cancelImage()
  public func selectImageRequestError(_ errorAssets: [Photos.PHAsset], errorIndexs: [Swift.Int])
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class HHNeedRealNameView : UIKit.UIView {
  public var realNameLinkClourse: (() -> ())?
  @objc deinit
}
@_hasMissingDesignatedInitializers public class HHNetCallChatInfo {
  public init()
  @objc deinit
}
@objc public enum HHCallType : Swift.Int {
  case child = 600000
  case adult = 600002
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum HHServerType {
  case pay
  case pacs
  case weixin
  public static func == (a: HHSDKVideo.HHServerType, b: HHSDKVideo.HHServerType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum HHRequestMethod {
  case get
  case post
  public static func == (a: HHSDKVideo.HHRequestMethod, b: HHSDKVideo.HHRequestMethod) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public let HH_RELOGIN_NOTIFICATION_STR: Swift.String
public struct HHRequestData {
  public init(body: [Swift.String : Any] = ["default_sw":"default"], param: [Swift.String : Any] = ["default_sw":"default"])
  public var mHttpBody: [Swift.String : Any]
  public var mParameters: [Swift.String : Any]
}
@_hasMissingDesignatedInitializers public class HHNetFetch {
  public static func request<E>(api: HHSDKVideo.HHBaseApi, data: HHSDKVideo.HHRequestData? = nil, result: ((E) -> Swift.Void)?, fail: HHSDKVideo.HHNetError? = nil) where E : HHSDKVideo.Mappable
  public static func requestArray<E>(api: HHSDKVideo.HHBaseApi, data: HHSDKVideo.HHRequestData? = nil, result: (([E]?) -> Swift.Void)?, fail: HHSDKVideo.HHNetError? = nil) where E : HHSDKVideo.Mappable
  public static func noDataRequest(api: HHSDKVideo.HHBaseApi, data: HHSDKVideo.HHRequestData? = nil, result: HHSDKVideo.NetResult?)
  public static func emptyRequest(api: HHSDKVideo.HHBaseApi, data: HHSDKVideo.HHRequestData? = nil, result: HHSDKVideo.NetResult?)
  @objc deinit
}
extension UIControl.State : Swift.Hashable {
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @IBDesignable public class HHPagerView : UIKit.UIView, UIKit.UICollectionViewDataSource, UIKit.UICollectionViewDelegate {
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic public func layoutSubviews()
  @objc override dynamic public func willMove(toWindow newWindow: UIKit.UIWindow?)
  @objc override dynamic public func prepareForInterfaceBuilder()
  @objc deinit
  @objc public func numberOfSections(in collectionView: UIKit.UICollectionView) -> Swift.Int
  @objc public func collectionView(_ collectionView: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @objc public func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
  @objc public func collectionView(_ collectionView: UIKit.UICollectionView, shouldHighlightItemAt indexPath: Foundation.IndexPath) -> Swift.Bool
  @objc public func collectionView(_ collectionView: UIKit.UICollectionView, didHighlightItemAt indexPath: Foundation.IndexPath)
  @objc public func collectionView(_ collectionView: UIKit.UICollectionView, shouldSelectItemAt indexPath: Foundation.IndexPath) -> Swift.Bool
  @objc public func collectionView(_ collectionView: UIKit.UICollectionView, didSelectItemAt indexPath: Foundation.IndexPath)
  @objc public func collectionView(_ collectionView: UIKit.UICollectionView, willDisplay cell: UIKit.UICollectionViewCell, forItemAt indexPath: Foundation.IndexPath)
  @objc public func collectionView(_ collectionView: UIKit.UICollectionView, didEndDisplaying cell: UIKit.UICollectionViewCell, forItemAt indexPath: Foundation.IndexPath)
  @objc public func scrollViewDidScroll(_ scrollView: UIKit.UIScrollView)
  @objc public func scrollViewWillBeginDragging(_ scrollView: UIKit.UIScrollView)
  @objc public func scrollViewWillEndDragging(_ scrollView: UIKit.UIScrollView, withVelocity velocity: CoreGraphics.CGPoint, targetContentOffset: Swift.UnsafeMutablePointer<CoreGraphics.CGPoint>)
  @objc public func scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
  @objc public func scrollViewDidEndScrollingAnimation(_ scrollView: UIKit.UIScrollView)
}
@objc public enum HHPagerViewTransformerType : Swift.Int {
  case crossFading
  case zoomOut
  case depth
  case overlap
  case linear
  case coverFlow
  case ferrisWheel
  case invertedFerrisWheel
  case cubic
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class UrlParams {
  public static func addUserParams(_ parameters: [Swift.String : Any]?) -> [Swift.String : Any]?
  public static func addCommon(_ param: [Swift.String : Any]?) -> [Swift.String : Any]
  public static func param2String(param: [Swift.String : Any]? = nil) -> Swift.String
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class HHPhotoPickerController : UIKit.UINavigationController {
  @objc override dynamic public func viewDidLoad()
  convenience public init(localPath: Swift.String? = nil, deleteMode: Swift.Bool = false, finish: (([HHSDKVideo.SDKCameraImageModel]?) -> Swift.Void)? = nil)
  @objc deinit
  @available(iOS 5.0, *)
  @objc override dynamic public init(navigationBarClass: Swift.AnyClass?, toolbarClass: Swift.AnyClass?)
  @objc override dynamic public init(rootViewController: UIKit.UIViewController)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
}
@objc @_hasMissingDesignatedInitializers public class HHPhotoPickerModel : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
public protocol HHPhotoPickerManagerDelegate {
  func selectImage(_ selecModels: [HHSDKVideo.HHPhotoPickerModel]?)
  func cancelImage()
  func selectImageRequestError(_ errorAssets: [Photos.PHAsset], errorIndexs: [Swift.Int])
}
@objc public class HHPhotoPickerManager : ObjectiveC.NSObject {
  public var viewDelegate: HHSDKVideo.HHPhotoPickerManagerDelegate?
  public var photoConfigModel: HHSDKVideo.HHPhotoConfigModel
  public var photoUIConfigModel: HHSDKVideo.HHPhotoUIConfigModel
  required public init(showVC: UIKit.UIViewController)
  public func showImagePicker()
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class HHPhotoConfigModel : ObjectiveC.NSObject {
  public var maxPreviewCount: Swift.Int
  public var maxSelectCount: Swift.Int {
    get
    set
  }
  public var minVideoSelectCount: Swift.Int {
    get
    set
  }
  public var maxVideoSelectCount: Swift.Int {
    get
    set
  }
  public var minSelectVideoDuration: Swift.Int
  public var maxSelectVideoDuration: Swift.Int
  public var cellCornerRadio: CoreGraphics.CGFloat
  public var languageType: HHSDKVideo.ZLLanguageType {
    get
    set
  }
  public var columnCount: Swift.Int {
    get
    set
  }
  public var sortAscending: Swift.Bool
  public var allowSelectImage: Swift.Bool
  public var allowTakePhotoInLibrary: Swift.Bool
  public var allowSelectOriginal: Swift.Bool
  public var allowSelectGif: Swift.Bool
  public var allowSelectVideo: Swift.Bool
  public var allowSelectLivePhoto: Swift.Bool
  public var allowEditImage: Swift.Bool
  public var allowMixSelect: Swift.Bool
  public var allowPreviewPhotos: Swift.Bool
  public var editImageWithDraw: Swift.Bool
  public var editImageWithClip: Swift.Bool
  public var editImageWithImageSticker: Swift.Bool
  public var editImageWithTextSticker: Swift.Bool
  public var editImageWithMosaic: Swift.Bool
  public var editImageWithFilter: Swift.Bool
  public var editImageWithAdjust: Swift.Bool
  public var editImageWitAdjustBrightness: Swift.Bool
  public var editImageWitAdjustContrast: Swift.Bool
  public var editImageWitAdjustSaturation: Swift.Bool
  public var shouldAnialysisAsset: Swift.Bool
  public var allowEditVideo: Swift.Bool {
    get
    set
  }
  public var saveNewImageAfterEdit: Swift.Bool
  public var allowDragSelect: Swift.Bool
  public var allowSlideSelect: Swift.Bool
  public var autoScrollWhenSlideSelectIsActive: Swift.Bool
  public var autoScrollMaxSpeed: CoreGraphics.CGFloat
  public var showCaptureImageOnTakePhotoBtn: Swift.Bool
  public var showSelectedIndex: Swift.Bool
  public var showSelectedMask: Swift.Bool
  public var showSelectedBorder: Swift.Bool
  public var showInvalidMask: Swift.Bool
  public var useCustomCamera: Swift.Bool
  public var flashMode: HHSDKVideo.ZLCameraConfiguration.FlashMode
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class HHPhotoUIConfigModel : ObjectiveC.NSObject {
  public var style: HHSDKVideo.ZLPhotoBrowserStyle
  public var bottomToolViewBtnNormalBgColor: UIKit.UIColor
  public var bottomToolViewBtnNormalBgColorOfPreviewVC: UIKit.UIColor
  @objc public var indexLabelBgColor: UIKit.UIColor
  @objc override dynamic public init()
  @objc deinit
}
public struct HHGetQuesetionModel : HHSDKVideo.Mappable {
  public var question: HHSDKVideo.HHQuesetionModel?
  public var rate: [HHSDKVideo.rateModel]?
  public init?(map: HHSDKVideo.Map)
  public init()
  public mutating func mapping(map: HHSDKVideo.Map)
  public func isHaveQ() -> Swift.Bool
}
public struct HHQuesetionModel : HHSDKVideo.Mappable {
  public var answerOne: Swift.String?
  public var answerTwo: Swift.String?
  public var content: Swift.String?
  public var id: Swift.Int?
  public init?(map: HHSDKVideo.Map)
  public init()
  public mutating func mapping(map: HHSDKVideo.Map)
}
public struct rateModel : HHSDKVideo.Mappable {
  public var createTime: Swift.Int?
  public var content: Swift.String?
  public var state: Swift.Int?
  public var id: Swift.Int?
  public var answerOne: Swift.String?
  public init?(map: HHSDKVideo.Map)
  public mutating func mapping(map: HHSDKVideo.Map)
}
@objc public enum HHRealNameType : Swift.Int {
  case normal, buyMedic
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers public class HHRealNameInputNewView : UIKit.UIView {
  @objc @IBOutlet weak public var idCardTF: UIKit.UITextField!
  public class func createRealNameInputNewView(realNameType: HHSDKVideo.HHRealNameType) -> HHSDKVideo.HHRealNameInputNewView
  public func showErroTip(tip: Swift.String)
  public func getInpuValues() -> [Swift.String : Swift.String]?
  @objc override dynamic public func awakeFromNib()
  public func load(userModel: HHSDKVideo.HHUserModel?)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension HHRealNameInputNewView : UIKit.UITextFieldDelegate {
  @objc dynamic public func textField(_ textField: UIKit.UITextField, shouldChangeCharactersIn range: Foundation.NSRange, replacementString string: Swift.String) -> Swift.Bool
  @objc dynamic public func textFieldDidBeginEditing(_ textField: UIKit.UITextField)
}
@_inheritsConvenienceInitializers @objc public class HHRealNameInputView : UIKit.UIView {
  public var nickName: Swift.String {
    get
    set
  }
  public class func createRealNameInputView(realNameType: HHSDKVideo.HHRealNameType) -> HHSDKVideo.HHRealNameInputView
  public var showPassPort: Swift.Bool {
    get
    set
  }
  public func showErroTip(tip: Swift.String)
  public func getInpuValues() -> [Swift.String : Swift.String]?
  @objc override dynamic public func awakeFromNib()
  public func load(userModel: HHSDKVideo.HHUserModel?)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension HHRealNameInputView : UIKit.UITextFieldDelegate {
  @objc dynamic public func textField(_ textField: UIKit.UITextField, shouldChangeCharactersIn range: Foundation.NSRange, replacementString string: Swift.String) -> Swift.Bool
}
public struct PrescriptionData {
  public init()
  public var mEleData: Swift.String
  public var mMessageId: Swift.String
  public var mRecordId: Swift.String
  public var mDrugOrderId: Swift.String
  public var isEleOrder: Swift.Bool
  public var isDDOrder: Swift.Bool
  public var isSuccess: Swift.Int
  public var cartUrl: Swift.String
}
@objc @_hasMissingDesignatedInitializers public class HHRealNameVC : UIKit.UIViewController {
  public var realNameSuccess: ((Swift.Bool?) -> ())?
  public init(userModel: HHSDKVideo.HHUserModel?, type: HHSDKVideo.HHRealNameType, isAntaiAppoint: Swift.Bool = false, prescriptionData: HHSDKVideo.PrescriptionData? = nil, showPssport: Swift.Bool = false, scene: Swift.String?)
  @objc override dynamic public func viewDidLoad()
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc deinit
}
public let KeyNetErrorStr: Swift.String
public let KeyNoNetErrorStr: Swift.String
public typealias HHNetError = ((Swift.String) -> (Swift.Void))
public typealias HHNetSuccessNoData = () -> Swift.Void
public typealias NetResult = (Swift.Bool, Swift.String) -> (Swift.Void)
public class HHRequest<T> where T : HHSDKVideo.Mappable {
  public typealias HHNetSuccess = (T) -> Swift.Void
  public typealias HHNetSuccessForArray = ([T]?) -> Swift.Void
  public typealias HHNetSuccessForString = (Swift.String) -> Swift.Void
  public var mRequestFail: HHSDKVideo.HHNetError?
  public var mRequestSuccess: HHSDKVideo.HHRequest<T>.HHNetSuccess?
  public var mRequestSuccessNoData: HHSDKVideo.HHNetSuccessNoData?
  public var mRequestSuccessForArray: HHSDKVideo.HHRequest<T>.HHNetSuccessForArray?
  public var mRequestSuccessForString: HHSDKVideo.HHRequest<T>.HHNetSuccessForString?
  public var errorCode: Swift.Int?
  public var mApi: HHSDKVideo.HHBaseApi?
  required public init(api: HHSDKVideo.HHBaseApi, requestData: HHSDKVideo.HHRequestData? = nil, postData: Foundation.Data? = nil)
  public func start()
  public func cancel()
  @objc deinit
}
extension HHRequest {
  public func startForArray(_ successCallBack: @escaping HHSDKVideo.HHRequest<T>.HHNetSuccessForArray, failCallBack: @escaping HHSDKVideo.HHNetError)
}
@objc public protocol HHRTC {
  @objc optional func setRoomId(roomId: Swift.String)
  @objc optional func setOrderId(orderId: Swift.String)
  @objc optional func startCall(callee: Swift.String, orderId: Swift.String?)
  @objc optional func enterRoom(orderId: Swift.String, roomId: Swift.String)
  @objc optional func switchLocalAudio(_ isOpen: Swift.Bool)
  @objc optional func switchLocalVideo(_ isOpen: Swift.Bool, localView: UIKit.UIView)
  @objc optional func openDoctorView(userId: Swift.String, view: UIKit.UIView)
  @objc optional func closeDoctorView(userId: Swift.String)
  @objc optional func switchCamera(_ isFront: Swift.Bool)
  @objc optional func switchCameraFlash(_ isOpen: Swift.Bool)
  @objc optional func sendMsg(isSignal: Swift.Bool, cmd: Swift.String, to: Swift.String, complete: ((Swift.String?) -> Swift.Void)?)
  @objc optional func leaveRoom()
  @objc optional func hangUp(callId: Swift.UInt64)
  @objc optional func startRing(audioId: Swift.Int)
  @objc optional func stopRing()
  @objc optional func snapshotVideo(userId: Swift.String?, imageBack: @escaping (UIKit.UIImage) -> ())
}
public protocol HHRTCDelegate : ObjectiveC.NSObject {
  func onEnterRoom()
  func checkHasAccept(_ isCmd: Swift.Bool, volumn: Swift.Int)
  func switchVideo(_ isToAudio: Swift.Bool)
  func onOtherViewAvailable(_ availableUserId: Swift.String, isAvailable: Swift.Bool)
  func onOtherAudioAvailable(_ userId: Swift.String, available: Swift.Bool)
  func onRemoteUserEnterRoom(_ userId: Swift.String)
  func onRemoteUserLeaveRoom(_ userId: Swift.String)
  func sendRTCLog(action: HHSDKVideo.TrtcLog, ex: Swift.String)
  func esdablishByRTC(error: HHSDKVideo.TrtcError, reason: Swift.String)
  func processMsg(cmd: HHSDKVideo.HHIMCmd, orderId: Swift.String, uuid: Swift.String)
  func waitingChanged(_ waitingInfo: HHSDKVideo.HHWaitDoctorModel)
  func waitingSuccess(_ doctorInfo: HHSDKVideo.HHDoctorModel, orderId: Swift.String)
  func onTransform(_ transInfo: HHSDKVideo.HHWaitDoctorModel)
  func onExitRoom()
  func hangup()
  func getDoctorUserId() -> Swift.String?
  func resumeRemote()
  func onFirstVideoFrame(_ userId: Swift.String?, width: Swift.Int32, height: Swift.Int32)
  func onUserVoiceVolume(_ userVolumes: [HHSDKVideo.HHTRTCVolumeInfo], totalVolume: Swift.Int)
}
@objc public class HHTRTCVolumeInfo : ObjectiveC.NSObject {
  public init(userId: Swift.String?, volume: Swift.Int?)
  @objc override dynamic public init()
  @objc deinit
}
public enum TrtcLog : Swift.String {
  case waitingRecall
  case missMessage
  case ignoreCall
  case enterError
  case doctorJoinRoom
  case micDidReady
  case netQuality
  case signalError
  case killEror
  case netDown
  case joinSuccess
  case schedule
  case noSchedule
  case video_busy
  case permit_error
  case transform
  case camera_close
  case camera_open
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum TrtcError : Swift.String {
  case callTimeOut
  case rtcError
  case enterRoomFail
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @objc public class HHSDKBaseOptions : ObjectiveC.NSObject {
  @objc public static let `default`: HHSDKVideo.HHSDKBaseOptions
  @objc public var isSDK: Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
@objc public protocol OptionProtocal {
  @objc var isDebug: Swift.Bool { get set }
  @objc var isDevelopment: Swift.Bool { get set }
  @objc var pHudManager: HHSDKVideo.HHVideoHUDable { get set }
  @objc var productId: Swift.String { get set }
  @objc var cerName: Swift.String? { get set }
  @objc var logLevel: HHSDKVideo.HHLogMode { get set }
  @objc var mExtension: Swift.String { get set }
  @objc var changeDoctorTime: Swift.Int { get set }
  @objc var logCallback: ((Swift.String) -> Swift.Void)? { get set }
  @objc var pVideoOptions: HHSDKVideo.VideoOptionsProtocol { get set }
  @objc var pMessageOptions: HHSDKVideo.MessageOptionsProtocol { get set }
  @objc var pUserCenterOptions: HHSDKVideo.UsercenterOptionsProtocol { get set }
  @objc var sdkVersion: Swift.String { get set }
  @objc var appVersion: Swift.String { get set }
  @objc var isTRTC: Swift.Bool { get set }
  @objc var needDNS: Swift.Bool { get set }
  @objc var shouldWaingCall: Swift.Bool { get set }
  @objc func setUserExtension(userExtension: Swift.String)
  @objc func setCallExtension(callExtension: Swift.String)
}
public var HMDefaultOpt: HHSDKVideo.OptionProtocal {
  get
}
@objc public protocol VideoOptionsProtocol {
  @objc var filterCallerInfo: Swift.Bool { get set }
  @objc var allowBeauty: Swift.Bool { get set }
  @objc var allowEvaluate: Swift.Bool { get set }
  @objc var allowAddMember: Swift.Bool { get set }
  @objc var allowMulti: Swift.Bool { get set }
  @objc var mCallExtension: Swift.String { get set }
  @objc var isShowDocInfo: Swift.Bool { get set }
  @objc var enableCloseCamera: Swift.Bool { get set }
  @objc var isCloseCameraCall: Swift.Bool { get set }
  @objc var isCloseRealNameInVideo: Swift.Bool { get set }
  @objc var showInviteInVideo: Swift.Bool { get set }
}
@objc public protocol MessageOptionsProtocol {
  @objc var isByPresent: Swift.Bool { get set }
  @available(*, deprecated, message: "已弃用，如有问题，请联系和缓")
  @objc var isFilterSummary: Swift.Bool { get set }
  @available(*, deprecated, message: "已弃用，如有问题，请联系和缓")
  @objc var isFilterMedicinal: Swift.Bool { get set }
  @objc var defaultDocHeader: Swift.String { get set }
  @objc var defaultDocName: Swift.String { get set }
  @objc var messageTitle: Swift.String { get set }
}
@objc public protocol UsercenterOptionsProtocol {
  @objc var enableVipInfo: Swift.Bool { get set }
  @objc var hideUserCenter: Swift.Bool { get set }
  @objc var enableActivate: Swift.Bool { get set }
  @objc var enableMedical: Swift.Bool { get set }
  @objc var enableAddMemberInDoc: Swift.Bool { get set }
  @objc var enableBuyService: Swift.Bool { get set }
  @objc var enablePopRealName: Swift.Bool { get set }
  @objc var isCloseMoreFunc: Swift.Bool { get set }
}
@_hasMissingDesignatedInitializers public class HHStatics {
  public static let `default`: HHSDKVideo.HHStatics
  public func send(params: [Swift.String : Any])
  @objc deinit
}
public struct CommonApi {
}
extension String {
  public func subFrom(_ index: Swift.Int) -> Swift.String
  public func subTo(_ index: Swift.Int) -> Swift.String
}
extension String {
  public func urlEncode() -> Swift.String
  public func stringByAppendingPathComponent(_ pathComponent: Swift.String) -> Swift.String
  public func hh_sha1() -> Swift.String
  public func string2base64String() -> Swift.String
  public func base64String2String() -> Swift.String
  public var lastPathComponent: Swift.String {
    get
  }
  public var pathExtension: Swift.String {
    get
  }
}
public enum hhToastPosition {
  case top
  case center
  case bottom
  public static func == (a: HHSDKVideo.hhToastPosition, b: HHSDKVideo.hhToastPosition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension UIView {
  public func hhmakeToast(_ message: Swift.String)
  public func hhmakeToast(_ message: Swift.String, duration: Foundation.TimeInterval, position: HHSDKVideo.hhToastPosition)
  public func hhmakeToast(_ message: Swift.String, duration: Foundation.TimeInterval, position: CoreGraphics.CGPoint)
  public func hhmakeToast(_ message: Swift.String, duration: Foundation.TimeInterval, position: HHSDKVideo.hhToastPosition, style: HHSDKVideo.hhToastStyle?)
  public func hhmakeToast(_ message: Swift.String, duration: Foundation.TimeInterval, position: CoreGraphics.CGPoint, style: HHSDKVideo.hhToastStyle?)
  public func hhmakeToast(_ message: Swift.String?, duration: Foundation.TimeInterval, position: HHSDKVideo.hhToastPosition, title: Swift.String?, image: UIKit.UIImage?, style: HHSDKVideo.hhToastStyle?, completion: ((Swift.Bool) -> Swift.Void)?)
  public func hhmakeToast(_ message: Swift.String?, duration: Foundation.TimeInterval, position: CoreGraphics.CGPoint, title: Swift.String?, image: UIKit.UIImage?, style: HHSDKVideo.hhToastStyle?, completion: ((Swift.Bool) -> Swift.Void)?)
  public func hhshowToast(_ toast: UIKit.UIView)
  public func hhshowToast(_ toast: UIKit.UIView, duration: Foundation.TimeInterval, position: HHSDKVideo.hhToastPosition, completion: ((Swift.Bool) -> Swift.Void)?)
  public func hhshowToast(_ toast: UIKit.UIView, duration: Foundation.TimeInterval, position: CoreGraphics.CGPoint, completion: ((Swift.Bool) -> Swift.Void)?)
  public func hhmakeToastActivity(_ position: HHSDKVideo.hhToastPosition)
  public func hhmakeToastActivity(_ position: CoreGraphics.CGPoint)
  public func hhhideToastActivity()
  @objc dynamic public func hhhandleToastTapped(_ recognizer: UIKit.UITapGestureRecognizer)
  @objc dynamic public func hhtoastTimerDidFinish(_ timer: Foundation.Timer)
  public func hhtoastViewForMessage(_ message: Swift.String?, title: Swift.String?, image: UIKit.UIImage?, style: HHSDKVideo.hhToastStyle) throws -> UIKit.UIView
}
public struct hhToastStyle {
  public init()
  public var backgroundColor: UIKit.UIColor
  public var titleColor: UIKit.UIColor
  public var messageColor: UIKit.UIColor
  public var maxWidthPercentage: CoreGraphics.CGFloat {
    get
    set
  }
  public var maxHeightPercentage: CoreGraphics.CGFloat {
    get
    set
  }
  public var horizontalPadding: CoreGraphics.CGFloat
  public var verticalPadding: CoreGraphics.CGFloat
  public var cornerRadius: CoreGraphics.CGFloat
  public var titleFont: UIKit.UIFont
  public var messageFont: UIKit.UIFont
  public var titleAlignment: UIKit.NSTextAlignment
  public var messageAlignment: UIKit.NSTextAlignment
  public var titleNumberOfLines: Swift.Int
  public var messageNumberOfLines: Swift.Int
  public var displayShadow: Swift.Bool
  public var shadowColor: UIKit.UIColor
  public var shadowOpacity: Swift.Float {
    get
    set
  }
  public var shadowRadius: CoreGraphics.CGFloat
  public var shadowOffset: CoreGraphics.CGSize
  public var imageSize: CoreGraphics.CGSize
  public var activitySize: CoreGraphics.CGSize
  public var fadeDuration: Swift.Double
}
extension UIAlertController {
  public func showAlter()
  public func present(animated: Swift.Bool, completion: (() -> Swift.Void)?)
  public func addAlterActions(_ actions: [UIKit.UIAlertAction])
  public func alterMessageStyle(_ fonsize: CoreGraphics.CGFloat = (HHDimens.isPad()) ? 18 : 16)
  public static func closeAlert(_ title: Swift.String = "", msg: Swift.String = "", keyString: Swift.String = "取消", closeBlock: (() -> Swift.Void)? = nil) -> UIKit.UIAlertController
}
extension UIButton {
  public func centerImageTitleVertically(spacing: CoreGraphics.CGFloat = 2)
  public func imageTitleHorizonal(spacing: CoreGraphics.CGFloat = 2)
}
extension UIImage {
  public func rotatedBy(_ degrees: CoreGraphics.CGFloat) -> UIKit.UIImage
}
extension UIImageView {
  public func hh_image(url: Foundation.URL?)
  public func hh_image(url: Foundation.URL?, complete: ((UIKit.UIImage?, Foundation.URL?) -> Swift.Void)?)
  public func hh_image(url: Foundation.URL?, placeHolder: UIKit.UIImage?)
  public func hh_image(url: Foundation.URL?, placeHolder: UIKit.UIImage?, progresses: ((CoreGraphics.CGFloat) -> Swift.Void)?, complete: ((UIKit.UIImage?, Foundation.URL?) -> Swift.Void)?)
}
public func hh_downloadImg(_ url: Foundation.URL?, finish: @escaping ((UIKit.UIImage?, Foundation.Data?, Swift.Error?) -> Swift.Void))
extension UIViewController {
  public func hhAddCloseBtn(_ atLeft: Swift.Bool? = nil, isDismiss: Swift.Bool = true, title: Swift.String = "关闭")
  @objc dynamic public func hhCloseThisController()
  @objc dynamic public func hhPopThisController()
  public func setNavigationTheme()
  public func setNaviBackImg(navi: UIKit.UINavigationController?, color: UIKit.UIColor)
  public func imageFromColor(color: UIKit.UIColor, size: CoreGraphics.CGSize) -> UIKit.UIImage
}
extension UIView {
  public var sj_width: CoreGraphics.CGFloat {
    get
    set
  }
  public var sj_height: CoreGraphics.CGFloat {
    get
    set
  }
  public var sj_size: CoreGraphics.CGSize {
    get
    set
  }
  public var sj_origin: CoreGraphics.CGPoint {
    get
    set
  }
  public var sj_x: CoreGraphics.CGFloat {
    get
    set
  }
  public var sj_y: CoreGraphics.CGFloat {
    get
    set
  }
  public var sj_centerX: CoreGraphics.CGFloat {
    get
    set
  }
  public var sj_centerY: CoreGraphics.CGFloat {
    get
    set
  }
  public var sj_top: CoreGraphics.CGFloat {
    get
    set
  }
  public var sj_bottom: CoreGraphics.CGFloat {
    get
    set
  }
  public var sj_right: CoreGraphics.CGFloat {
    get
    set
  }
  public var sj_left: CoreGraphics.CGFloat {
    get
    set
  }
}
extension UIView {
  public class func viewFromNib<T>(_ aClass: T.Type, frameworkPath: Swift.String) -> T
}
public typealias onSDKProgress = ((CoreGraphics.CGFloat, Swift.String) -> Swift.Void)
public typealias onSDKUploadOnce = ((Swift.Bool, HHSDKVideo.SDKUploadModel) -> Swift.Void)
public typealias onSDKFinished = (() -> Swift.Void)
public class SDKUploadConfig {
  public var progress: HHSDKVideo.onSDKProgress?
  public var uploadOnce: HHSDKVideo.onSDKUploadOnce?
  public var finished: HHSDKVideo.onSDKFinished?
  public var orderId: Swift.String?
  public init()
  @objc deinit
}
public class SDKUploadModel {
  public var clouldKey: Swift.String?
  public var filePath: Swift.String? {
    get
    set
  }
  public var smallImage: Swift.String
  public var bigImage: Swift.String
  public var state: HHSDKVideo.SDKUploadState?
  public var isVideo: Swift.Bool
  public init()
  public init(full: Swift.String?, scale: Swift.String)
  public init(clouldKey: Swift.String?, filePath: Swift.String?, uploadTime: Foundation.TimeInterval?, name: Swift.String?, smallImage: Swift.String)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class SDKUploadState {
  public var file: Swift.String?
  public var isSelect: Swift.Bool
  public var changed: (() -> Swift.Void)?
  public var progress: Swift.Float {
    get
    set
  }
  public func isSuccess() -> Swift.Bool
  public func isFail() -> Swift.Bool
  @objc deinit
}
@_hasMissingDesignatedInitializers public class HHUrl {
  public static func domains() -> [Swift.String]
  public static var timeOffset: Swift.Double
  public static func urlForPay() -> Swift.String
  public static func urlForFamily() -> Swift.String
  public static func urlForWeixin() -> Swift.String
  public static func baseUrl() -> Swift.String
  public static func baseWMPUrl() -> Swift.String
  public static func basePayUrl() -> Swift.String
  public static func baseMedicUrl() -> Swift.String
  public static func baseSecUrl() -> Swift.String
  public static func testURL() -> Swift.String
  public static func fileLogUrl(_ name: Swift.String, orderId: Swift.String) -> Foundation.URL
  public static func uploadHealthFileUrl(orderId: Swift.String) -> Swift.String
  public static func expertDetailUrl(expertId: Swift.String) -> Swift.String
  public static func homeMessageUrl() -> Swift.String
  public static func buyVIPUrl() -> Swift.String
  public static func productRightUrl() -> Swift.String
  @objc deinit
}
extension HHUrl {
  public static func headers(host: Swift.String) -> [Swift.String : Swift.String]
}
public func languagePrefix() -> Swift.String
@_hasMissingDesignatedInitializers public class HHUserDefaults {
  public class func setString(_ str: Swift.String, key: Swift.String)
  public class func stringValue(_ key: Swift.String) -> Swift.String?
  public class func setArray(_ array: [Swift.AnyObject], key: Swift.String)
  public class func arrayForKey(_ key: Swift.String) -> [Swift.AnyObject]?
  public class func setImage(_ image: UIKit.UIImage, key: Swift.String)
  public class func imageForKey(_ key: Swift.String) -> UIKit.UIImage?
  @objc deinit
}
extension HHUserDefaults {
  public class func setBool(_ flag: Swift.Bool, key: Swift.String)
  public class func boolForKey(_ key: Swift.String) -> Swift.Bool
  public class func setObject(_ obj: Swift.AnyObject, key: Swift.String)
  public class func objectForKey(_ key: Swift.String) -> Swift.AnyObject?
  public class func removeObject(_ key: Swift.String)
}
extension HHUserDefaults {
  public class func setData(_ data: Foundation.Data?, key: Swift.String)
  public class func dataForKey(_ key: Swift.String) -> Foundation.Data?
  public class func userDefaults() -> Foundation.UserDefaults
  public class func synchronize()
  public class func encryptkey(_ key: Swift.String) -> Swift.String
}
public struct HHMemberInfoModel : HHSDKVideo.Mappable {
  public var productServiceId: Swift.Int?
  public var productStatusDescn: Swift.String?
  public init?(map: HHSDKVideo.Map)
  public mutating func mapping(map: HHSDKVideo.Map)
}
public class HHUserModel : HHSDKVideo.Mappable {
  public var age: Swift.String?
  public var companyLogo: Swift.String?
  public var birthday: Swift.Int64?
  public var loginname: Swift.String?
  public var name: Swift.String?
  public var photourl: Swift.String?
  public var pid: Swift.Int?
  public var product: HHSDKVideo.HHMemberInfoModel?
  public var relation: Swift.String?
  public var sex: Swift.String?
  public var uuid: Swift.Int?
  public var userToken: Swift.String?
  public var videoToken: Swift.String?
  public var auth: Swift.Bool?
  public var isMember: Swift.Bool?
  public var isAccount: Swift.Bool?
  public var license: Swift.String?
  public var userSig: Swift.String?
  public var phoneNum: Swift.String?
  required public init?(map: HHSDKVideo.Map)
  public init()
  public func mapping(map: HHSDKVideo.Map)
  @objc deinit
}
public struct HHUserProtocolModel : HHSDKVideo.Mappable {
  public init?(map: HHSDKVideo.Map)
  public mutating func mapping(map: HHSDKVideo.Map)
}
open class HHValueObservable<T> {
  public typealias Observer = (T) -> Swift.Void
  open var observer: HHSDKVideo.HHValueObservable<T>.Observer?
  open func observe(_ observer: HHSDKVideo.HHValueObservable<T>.Observer?)
  open var value: T {
    get
    set
  }
  public init(_ v: T)
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class HHVideoLocation : ObjectiveC.NSObject {
  @objc public static let `default`: HHSDKVideo.HHVideoLocation
  @objc public func startLocation(lng: Swift.String, lat: Swift.String)
  @objc public func closeLocation()
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class HHVideoSDK : ObjectiveC.NSObject {
  @objc public static let `default`: HHSDKVideo.HHVideoSDK
  public var mHHRTC: HHSDKVideo.HHRTC?
  public var mSDKOption: HHSDKVideo.OptionProtocal?
  weak public var mCallDelegate: HHSDKVideo.HHCallDelegate?
  weak public var mHHRTCDelegate: HHSDKVideo.HHRTCDelegate?
  weak public var videoManager: HHSDKVideo.HHBaseVideoDelegate?
  public var expertVideoCallback: (() -> Swift.Void)?
  public var autoLoginCheck: (() -> Swift.Void)?
  public var onReceiveNewMsg: (([Swift.String : Any]) -> Swift.Void)?
  public var userProtocolModel: HHSDKVideo.HHUserProtocolModel?
  @objc public var photosPreview: ((Swift.Array<Swift.String>) -> Swift.Void)?
  @objc public var isLogined: Swift.Bool {
    @objc get
  }
  @objc public func start(option: HHSDKVideo.OptionProtocal, im: HHSDKVideo.HHIM, rtc: HHSDKVideo.HHRTC)
  @objc public func login(userToken: Swift.String, completion: @escaping HHSDKVideo.HHLoginHandler)
  @objc public func autoLogin(uuid: Swift.Int, completion: @escaping HHSDKVideo.HHLoginHandler)
  @objc public func logout(_ callback: ((Swift.String?) -> Swift.Void)? = nil)
  @objc public func terminate()
  @objc public func setAlipayHook(alipayCallback: @escaping (Swift.String, Swift.String, @escaping (([Swift.String : Any]) -> Swift.Void)) -> Swift.Bool)
  @objc override dynamic public init()
  @objc deinit
}
extension HHVideoSDK {
  @objc dynamic public func startCall(_ type: HHSDKVideo.HHCallType = .adult, scene: Swift.String? = nil, callDelegate: HHSDKVideo.HHCallDelegate? = nil)
  @objc dynamic public func startNewCall(_ uuid: Swift.Int, type: HHSDKVideo.HHCallType = .adult, callDelegate: HHSDKVideo.HHCallDelegate? = nil)
  @objc dynamic public func startCall(_ uuid: Swift.Int, scene: Swift.String? = nil, type: HHSDKVideo.HHCallType = .adult, callDelegate: HHSDKVideo.HHCallDelegate? = nil)
}
extension HHVideoSDK {
  @objc dynamic public func startTeamCall(_ type: HHSDKVideo.HHCallType, callee: HHSDKVideo.HHCallerInfo, callDelegate: HHSDKVideo.HHCallDelegate? = nil)
}
extension HHVideoSDK {
  @objc dynamic public func call(_ memberToken: Swift.String, scene: Swift.String? = nil)
}
extension HHVideoSDK {
  public func reJoinRoom(orderId: Swift.String)
  public func waitExpert(userToken: Swift.String, callOrderId: Swift.String)
  public func waitHealth(userToken: Swift.String, callOrderId: Swift.String, beginTime: Swift.String)
}
extension HHVideoSDK {
  @objc dynamic public func startMemberCall(needSelectMember: Swift.Bool = true)
}
extension HHVideoSDK {
  @objc dynamic public func skipChatHome(isByPresent: Swift.Bool = false, vc: UIKit.UIViewController? = nil)
  @objc dynamic public func skipChatHome(_ nav: UIKit.UINavigationController)
  @objc dynamic public func chatHomeVC() -> UIKit.UIViewController?
}
extension HHVideoSDK {
  public func sendBaseLog(ex: [Swift.String : Swift.String]? = nil, action: [Swift.String : Swift.String]? = nil)
}
public func topviewController() -> UIKit.UIViewController?
extension HHVideoSDK {
  @objc dynamic public func loginForThirdId(_ thirdInfo: [Swift.String : Any], completion: @escaping HHSDKVideo.HHLoginHandler)
}
extension HHVideoSDK {
  public func checkProtocolUpdate(agreeBlock: ((Swift.Bool) -> Swift.Void)?)
}
extension HHVideoSDK {
  @objc dynamic public func getMedicDetail(userToken: Swift.String, medicId: Swift.String) -> Swift.String
  @objc dynamic public func getMedicList(userToken: Swift.String) -> Swift.String
  @objc dynamic public func getAllMedics(userToken: Swift.String) -> Swift.String
}
extension HHVideoSDK {
  @objc dynamic public func onKickedOffline()
}
public struct HHWaitDoctorModel : HHSDKVideo.Mappable {
  public var isNormalTrans: Swift.Bool
  public var deptId: Swift.String?
  public var uuid: Swift.Int?
  public var transUuid: Swift.Int?
  public init?(map: HHSDKVideo.Map)
  public func isWaiting() -> Swift.Bool
  public mutating func mapping(map: HHSDKVideo.Map)
}
public struct HHWaitingCallModel : HHSDKVideo.Mappable {
  public init?(map: HHSDKVideo.Map)
  public func isCall() -> Swift.Bool
  public mutating func mapping(map: HHSDKVideo.Map)
}
public struct HHAgentCallModel : HHSDKVideo.Mappable {
  public init?(map: HHSDKVideo.Map)
  public func isAgent() -> Swift.Bool
  public func isTransform() -> Swift.Bool
  public mutating func mapping(map: HHSDKVideo.Map)
}
public struct HKDF {
  public enum Error : Swift.Error {
    case invalidInput
    case derivedKeyTooLong
    public static func == (a: HHSDKVideo.HKDF.Error, b: HHSDKVideo.HKDF.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>? = nil, info: Swift.Array<Swift.UInt8>? = nil, keyLength: Swift.Int? = nil, variant: HHSDKVideo.HMAC.Variant = .sha256) throws
  public func calculate() throws -> Swift.Array<Swift.UInt8>
}
final public class HMAC : HHSDKVideo.CryptoAuthenticator {
  public enum Error : Swift.Error {
    case authenticateError
    case invalidInput
    public static func == (a: HHSDKVideo.HMAC.Error, b: HHSDKVideo.HMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant {
    case sha1, sha256, sha384, sha512, md5
    public static func == (a: HHSDKVideo.HMAC.Variant, b: HHSDKVideo.HMAC.Variant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(key: Swift.Array<Swift.UInt8>, variant: HHSDKVideo.HMAC.Variant = .md5)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension HMAC {
  convenience public init(key: Swift.String, variant: HHSDKVideo.HMAC.Variant = .md5) throws
}
public protocol ImmutableMappable : HHSDKVideo.BaseMappable {
  init(map: HHSDKVideo.Map) throws
}
extension ImmutableMappable {
  public func mapping(map: HHSDKVideo.Map)
  public init(JSONString: Swift.String, context: HHSDKVideo.MapContext? = nil) throws
  public init(JSON: [Swift.String : Any], context: HHSDKVideo.MapContext? = nil) throws
  public init(JSONObject: Any, context: HHSDKVideo.MapContext? = nil) throws
}
extension Map {
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> Transform.Object where Transform : HHSDKVideo.TransformType
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T where T : Swift.RawRepresentable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T? where T : Swift.RawRepresentable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [T] where T : Swift.RawRepresentable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [T]? where T : Swift.RawRepresentable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T where T : HHSDKVideo.BaseMappable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T? where T : HHSDKVideo.BaseMappable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [T] where T : HHSDKVideo.BaseMappable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [T]? where T : HHSDKVideo.BaseMappable
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [Transform.Object] where Transform : HHSDKVideo.TransformType
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [Swift.String : T] where T : HHSDKVideo.BaseMappable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [Swift.String : T]? where T : HHSDKVideo.BaseMappable
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [Swift.String : Transform.Object] where Transform : HHSDKVideo.TransformType
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [[T]]? where T : HHSDKVideo.BaseMappable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [[T]] where T : HHSDKVideo.BaseMappable
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [[Transform.Object]] where Transform : HHSDKVideo.TransformType
}
extension Mapper where N : HHSDKVideo.ImmutableMappable {
  final public func map(JSON: [Swift.String : Any]) throws -> N
  final public func map(JSONString: Swift.String) throws -> N
  final public func map(JSONObject: Any) throws -> N
  final public func mapArray(JSONArray: [[Swift.String : Any]]) throws -> [N]
  final public func mapArray(JSONString: Swift.String) throws -> [N]
  final public func mapArray(JSONObject: Any) throws -> [N]
  final public func mapDictionary(JSONString: Swift.String) throws -> [Swift.String : N]
  final public func mapDictionary(JSONObject: Any?) throws -> [Swift.String : N]
  final public func mapDictionary(JSON: [Swift.String : [Swift.String : Any]]) throws -> [Swift.String : N]
  final public func mapDictionaryOfArrays(JSONObject: Any?) throws -> [Swift.String : [N]]
  final public func mapDictionaryOfArrays(JSON: [Swift.String : [[Swift.String : Any]]]) throws -> [Swift.String : [N]]
  final public func mapArrayOfArrays(JSONObject: Any?) throws -> [[N]]
}
public func <- <T>(left: inout T, right: HHSDKVideo.Map) where T : Swift.SignedInteger
public func <- <T>(left: inout T?, right: HHSDKVideo.Map) where T : Swift.SignedInteger
public func <- <T>(left: inout T, right: HHSDKVideo.Map) where T : Swift.UnsignedInteger
public func <- <T>(left: inout T?, right: HHSDKVideo.Map) where T : Swift.UnsignedInteger
extension DateFormatter {
  convenience public init(withFormat format: Swift.String, locale: Swift.String)
}
open class ISO8601DateTransform : HHSDKVideo.DateFormatterTransform {
  public init()
  override public init(dateFormatter: Foundation.DateFormatter)
  @objc deinit
}
public let KeychainAccessErrorDomain: Swift.String
public enum ItemClass {
  case genericPassword
  case internetPassword
}
public enum ProtocolType {
  case ftp
  case ftpAccount
  case http
  case irc
  case nntp
  case pop3
  case smtp
  case socks
  case imap
  case ldap
  case appleTalk
  case afp
  case telnet
  case ssh
  case ftps
  case https
  case httpProxy
  case httpsProxy
  case ftpProxy
  case smb
  case rtsp
  case rtspProxy
  case daap
  case eppc
  case ipp
  case nntps
  case ldaps
  case telnetS
  case imaps
  case ircs
  case pop3S
}
public enum AuthenticationType {
  case ntlm
  case msn
  case dpa
  case rpa
  case httpBasic
  case httpDigest
  case htmlForm
  case `default`
}
public enum Accessibility {
  case whenUnlocked
  case afterFirstUnlock
  case always
  @available(iOS 8.0, macOS 10.10, *)
  case whenPasscodeSetThisDeviceOnly
  case whenUnlockedThisDeviceOnly
  case afterFirstUnlockThisDeviceOnly
  case alwaysThisDeviceOnly
}
public struct AuthenticationPolicy : Swift.OptionSet {
  @available(iOS 8.0, macOS 10.10, *)
  @available(watchOS, unavailable)
  public static let userPresence: HHSDKVideo.AuthenticationPolicy
  @available(iOS 9.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  public static let touchIDAny: HHSDKVideo.AuthenticationPolicy
  @available(iOS 9.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  public static let touchIDCurrentSet: HHSDKVideo.AuthenticationPolicy
  @available(iOS 9.0, macOS 10.11, *)
  @available(watchOS, unavailable)
  public static let devicePasscode: HHSDKVideo.AuthenticationPolicy
  @available(iOS 9.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  public static let or: HHSDKVideo.AuthenticationPolicy
  @available(iOS 9.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  public static let and: HHSDKVideo.AuthenticationPolicy
  @available(iOS 9.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  public static let privateKeyUsage: HHSDKVideo.AuthenticationPolicy
  @available(iOS 9.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  public static let applicationPassword: HHSDKVideo.AuthenticationPolicy
  public let rawValue: Swift.UInt
  public init(rawValue: Swift.UInt)
  public typealias ArrayLiteralElement = HHSDKVideo.AuthenticationPolicy
  public typealias Element = HHSDKVideo.AuthenticationPolicy
  public typealias RawValue = Swift.UInt
}
public struct Attributes {
  public var `class`: Swift.String? {
    get
  }
  public var data: Foundation.Data? {
    get
  }
  public var ref: Foundation.Data? {
    get
  }
  public var persistentRef: Foundation.Data? {
    get
  }
  public var accessible: Swift.String? {
    get
  }
  public var accessControl: Security.SecAccessControl? {
    get
  }
  public var accessGroup: Swift.String? {
    get
  }
  public var synchronizable: Swift.Bool? {
    get
  }
  public var creationDate: Foundation.Date? {
    get
  }
  public var modificationDate: Foundation.Date? {
    get
  }
  public var attributeDescription: Swift.String? {
    get
  }
  public var comment: Swift.String? {
    get
  }
  public var creator: Swift.String? {
    get
  }
  public var type: Swift.String? {
    get
  }
  public var label: Swift.String? {
    get
  }
  public var isInvisible: Swift.Bool? {
    get
  }
  public var isNegative: Swift.Bool? {
    get
  }
  public var account: Swift.String? {
    get
  }
  public var service: Swift.String? {
    get
  }
  public var generic: Foundation.Data? {
    get
  }
  public var securityDomain: Swift.String? {
    get
  }
  public var server: Swift.String? {
    get
  }
  public var `protocol`: Swift.String? {
    get
  }
  public var authenticationType: Swift.String? {
    get
  }
  public var port: Swift.Int? {
    get
  }
  public var path: Swift.String? {
    get
  }
  public subscript(key: Swift.String) -> Any? {
    get
  }
}
@_hasMissingDesignatedInitializers final public class Keychain {
  final public var itemClass: HHSDKVideo.ItemClass {
    get
  }
  final public var service: Swift.String {
    get
  }
  final public var accessGroup: Swift.String? {
    get
  }
  final public var server: Foundation.URL {
    get
  }
  final public var protocolType: HHSDKVideo.ProtocolType {
    get
  }
  final public var authenticationType: HHSDKVideo.AuthenticationType {
    get
  }
  final public var accessibility: HHSDKVideo.Accessibility {
    get
  }
  @available(iOS 8.0, macOS 10.10, *)
  @available(watchOS, unavailable)
  final public var authenticationPolicy: HHSDKVideo.AuthenticationPolicy? {
    get
  }
  final public var synchronizable: Swift.Bool {
    get
  }
  final public var label: Swift.String? {
    get
  }
  final public var comment: Swift.String? {
    get
  }
  @available(iOS 8.0, macOS 10.10, *)
  @available(watchOS, unavailable)
  final public var authenticationPrompt: Swift.String? {
    get
  }
  @available(iOS 9.0, macOS 10.11, *)
  final public var authenticationContext: LocalAuthentication.LAContext? {
    get
  }
  convenience public init()
  convenience public init(service: Swift.String)
  convenience public init(accessGroup: Swift.String)
  convenience public init(service: Swift.String, accessGroup: Swift.String)
  convenience public init(server: Swift.String, protocolType: HHSDKVideo.ProtocolType, authenticationType: HHSDKVideo.AuthenticationType = .default)
  convenience public init(server: Foundation.URL, protocolType: HHSDKVideo.ProtocolType, authenticationType: HHSDKVideo.AuthenticationType = .default)
  final public func accessibility(_ accessibility: HHSDKVideo.Accessibility) -> HHSDKVideo.Keychain
  @available(iOS 8.0, macOS 10.10, *)
  @available(watchOS, unavailable)
  final public func accessibility(_ accessibility: HHSDKVideo.Accessibility, authenticationPolicy: HHSDKVideo.AuthenticationPolicy) -> HHSDKVideo.Keychain
  final public func synchronizable(_ synchronizable: Swift.Bool) -> HHSDKVideo.Keychain
  final public func label(_ label: Swift.String) -> HHSDKVideo.Keychain
  final public func comment(_ comment: Swift.String) -> HHSDKVideo.Keychain
  final public func attributes(_ attributes: [Swift.String : Any]) -> HHSDKVideo.Keychain
  @available(iOS 8.0, macOS 10.10, *)
  @available(watchOS, unavailable)
  final public func authenticationPrompt(_ authenticationPrompt: Swift.String) -> HHSDKVideo.Keychain
  @available(iOS 9.0, macOS 10.11, *)
  final public func authenticationContext(_ authenticationContext: LocalAuthentication.LAContext) -> HHSDKVideo.Keychain
  final public func get(_ key: Swift.String) throws -> Swift.String?
  final public func getString(_ key: Swift.String) throws -> Swift.String?
  final public func getData(_ key: Swift.String) throws -> Foundation.Data?
  final public func get<T>(_ key: Swift.String, handler: (HHSDKVideo.Attributes?) -> T) throws -> T
  final public func set(_ value: Swift.String, key: Swift.String) throws
  final public func set(_ value: Foundation.Data, key: Swift.String) throws
  final public subscript(key: Swift.String) -> Swift.String? {
    get
    set
  }
  final public subscript(string key: Swift.String) -> Swift.String? {
    get
    set
  }
  final public subscript(data key: Swift.String) -> Foundation.Data? {
    get
    set
  }
  final public subscript(attributes key: Swift.String) -> HHSDKVideo.Attributes? {
    get
  }
  final public func remove(_ key: Swift.String) throws
  final public func removeAll() throws
  final public func contains(_ key: Swift.String) throws -> Swift.Bool
  final public class func allKeys(_ itemClass: HHSDKVideo.ItemClass) -> [(Swift.String, Swift.String)]
  final public func allKeys() -> [Swift.String]
  final public class func allItems(_ itemClass: HHSDKVideo.ItemClass) -> [[Swift.String : Any]]
  final public func allItems() -> [[Swift.String : Any]]
  @available(iOS 8.0, *)
  final public func getSharedPassword(_ completion: @escaping (Swift.String?, Swift.String?, Swift.Error?) -> () = { account, password, error -> () in })
  @available(iOS 8.0, *)
  final public func getSharedPassword(_ account: Swift.String, completion: @escaping (Swift.String?, Swift.Error?) -> () = { password, error -> () in })
  @available(iOS 8.0, *)
  final public func setSharedPassword(_ password: Swift.String, account: Swift.String, completion: @escaping (Swift.Error?) -> () = { e -> () in })
  @available(iOS 8.0, *)
  final public func removeSharedPassword(_ account: Swift.String, completion: @escaping (Swift.Error?) -> () = { e -> () in })
  @available(iOS 8.0, *)
  final public class func requestSharedWebCredential(_ completion: @escaping ([[Swift.String : Swift.String]], Swift.Error?) -> () = { credentials, error -> () in })
  @available(iOS 8.0, *)
  final public class func requestSharedWebCredential(domain: Swift.String, completion: @escaping ([[Swift.String : Swift.String]], Swift.Error?) -> () = { credentials, error -> () in })
  @available(iOS 8.0, *)
  final public class func requestSharedWebCredential(domain: Swift.String, account: Swift.String, completion: @escaping ([[Swift.String : Swift.String]], Swift.Error?) -> () = { credentials, error -> () in })
  @available(iOS 8.0, *)
  final public class func generatePassword() -> Swift.String
  @objc deinit
}
extension Keychain : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  final public var description: Swift.String {
    get
  }
  final public var debugDescription: Swift.String {
    get
  }
}
extension Attributes : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension ItemClass : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension ProtocolType : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension AuthenticationType : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension Accessibility : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
public enum Status : Darwin.OSStatus, Swift.Error {
  case success
  case unimplemented
  case diskFull
  case io
  case opWr
  case param
  case wrPerm
  case allocate
  case userCanceled
  case badReq
  case internalComponent
  case notAvailable
  case readOnly
  case authFailed
  case noSuchKeychain
  case invalidKeychain
  case duplicateKeychain
  case duplicateCallback
  case invalidCallback
  case duplicateItem
  case itemNotFound
  case bufferTooSmall
  case dataTooLarge
  case noSuchAttr
  case invalidItemRef
  case invalidSearchRef
  case noSuchClass
  case noDefaultKeychain
  case interactionNotAllowed
  case readOnlyAttr
  case wrongSecVersion
  case keySizeNotAllowed
  case noStorageModule
  case noCertificateModule
  case noPolicyModule
  case interactionRequired
  case dataNotAvailable
  case dataNotModifiable
  case createChainFailed
  case invalidPrefsDomain
  case inDarkWake
  case aclNotSimple
  case policyNotFound
  case invalidTrustSetting
  case noAccessForItem
  case invalidOwnerEdit
  case trustNotAvailable
  case unsupportedFormat
  case unknownFormat
  case keyIsSensitive
  case multiplePrivKeys
  case passphraseRequired
  case invalidPasswordRef
  case invalidTrustSettings
  case noTrustSettings
  case pkcs12VerifyFailure
  case invalidCertificate
  case notSigner
  case policyDenied
  case invalidKey
  case decode
  case `internal`
  case unsupportedAlgorithm
  case unsupportedOperation
  case unsupportedPadding
  case itemInvalidKey
  case itemInvalidKeyType
  case itemInvalidValue
  case itemClassMissing
  case itemMatchUnsupported
  case useItemListUnsupported
  case useKeychainUnsupported
  case useKeychainListUnsupported
  case returnDataUnsupported
  case returnAttributesUnsupported
  case returnRefUnsupported
  case returnPersitentRefUnsupported
  case valueRefUnsupported
  case valuePersistentRefUnsupported
  case returnMissingPointer
  case matchLimitUnsupported
  case itemIllegalQuery
  case waitForCallback
  case missingEntitlement
  case upgradePending
  case mpSignatureInvalid
  case otrTooOld
  case otrIDTooNew
  case serviceNotAvailable
  case insufficientClientID
  case deviceReset
  case deviceFailed
  case appleAddAppACLSubject
  case applePublicKeyIncomplete
  case appleSignatureMismatch
  case appleInvalidKeyStartDate
  case appleInvalidKeyEndDate
  case conversionError
  case appleSSLv2Rollback
  case quotaExceeded
  case fileTooBig
  case invalidDatabaseBlob
  case invalidKeyBlob
  case incompatibleDatabaseBlob
  case incompatibleKeyBlob
  case hostNameMismatch
  case unknownCriticalExtensionFlag
  case noBasicConstraints
  case noBasicConstraintsCA
  case invalidAuthorityKeyID
  case invalidSubjectKeyID
  case invalidKeyUsageForPolicy
  case invalidExtendedKeyUsage
  case invalidIDLinkage
  case pathLengthConstraintExceeded
  case invalidRoot
  case crlExpired
  case crlNotValidYet
  case crlNotFound
  case crlServerDown
  case crlBadURI
  case unknownCertExtension
  case unknownCRLExtension
  case crlNotTrusted
  case crlPolicyFailed
  case idpFailure
  case smimeEmailAddressesNotFound
  case smimeBadExtendedKeyUsage
  case smimeBadKeyUsage
  case smimeKeyUsageNotCritical
  case smimeNoEmailAddress
  case smimeSubjAltNameNotCritical
  case sslBadExtendedKeyUsage
  case ocspBadResponse
  case ocspBadRequest
  case ocspUnavailable
  case ocspStatusUnrecognized
  case endOfData
  case incompleteCertRevocationCheck
  case networkFailure
  case ocspNotTrustedToAnchor
  case recordModified
  case ocspSignatureError
  case ocspNoSigner
  case ocspResponderMalformedReq
  case ocspResponderInternalError
  case ocspResponderTryLater
  case ocspResponderSignatureRequired
  case ocspResponderUnauthorized
  case ocspResponseNonceMismatch
  case codeSigningBadCertChainLength
  case codeSigningNoBasicConstraints
  case codeSigningBadPathLengthConstraint
  case codeSigningNoExtendedKeyUsage
  case codeSigningDevelopment
  case resourceSignBadCertChainLength
  case resourceSignBadExtKeyUsage
  case trustSettingDeny
  case invalidSubjectName
  case unknownQualifiedCertStatement
  case mobileMeRequestQueued
  case mobileMeRequestRedirected
  case mobileMeServerError
  case mobileMeServerNotAvailable
  case mobileMeServerAlreadyExists
  case mobileMeServerServiceErr
  case mobileMeRequestAlreadyPending
  case mobileMeNoRequestPending
  case mobileMeCSRVerifyFailure
  case mobileMeFailedConsistencyCheck
  case notInitialized
  case invalidHandleUsage
  case pvcReferentNotFound
  case functionIntegrityFail
  case internalError
  case memoryError
  case invalidData
  case mdsError
  case invalidPointer
  case selfCheckFailed
  case functionFailed
  case moduleManifestVerifyFailed
  case invalidGUID
  case invalidHandle
  case invalidDBList
  case invalidPassthroughID
  case invalidNetworkAddress
  case crlAlreadySigned
  case invalidNumberOfFields
  case verificationFailure
  case unknownTag
  case invalidSignature
  case invalidName
  case invalidCertificateRef
  case invalidCertificateGroup
  case tagNotFound
  case invalidQuery
  case invalidValue
  case callbackFailed
  case aclDeleteFailed
  case aclReplaceFailed
  case aclAddFailed
  case aclChangeFailed
  case invalidAccessCredentials
  case invalidRecord
  case invalidACL
  case invalidSampleValue
  case incompatibleVersion
  case privilegeNotGranted
  case invalidScope
  case pvcAlreadyConfigured
  case invalidPVC
  case emmLoadFailed
  case emmUnloadFailed
  case addinLoadFailed
  case invalidKeyRef
  case invalidKeyHierarchy
  case addinUnloadFailed
  case libraryReferenceNotFound
  case invalidAddinFunctionTable
  case invalidServiceMask
  case moduleNotLoaded
  case invalidSubServiceID
  case attributeNotInContext
  case moduleManagerInitializeFailed
  case moduleManagerNotFound
  case eventNotificationCallbackNotFound
  case inputLengthError
  case outputLengthError
  case privilegeNotSupported
  case deviceError
  case attachHandleBusy
  case notLoggedIn
  case algorithmMismatch
  case keyUsageIncorrect
  case keyBlobTypeIncorrect
  case keyHeaderInconsistent
  case unsupportedKeyFormat
  case unsupportedKeySize
  case invalidKeyUsageMask
  case unsupportedKeyUsageMask
  case invalidKeyAttributeMask
  case unsupportedKeyAttributeMask
  case invalidKeyLabel
  case unsupportedKeyLabel
  case invalidKeyFormat
  case unsupportedVectorOfBuffers
  case invalidInputVector
  case invalidOutputVector
  case invalidContext
  case invalidAlgorithm
  case invalidAttributeKey
  case missingAttributeKey
  case invalidAttributeInitVector
  case missingAttributeInitVector
  case invalidAttributeSalt
  case missingAttributeSalt
  case invalidAttributePadding
  case missingAttributePadding
  case invalidAttributeRandom
  case missingAttributeRandom
  case invalidAttributeSeed
  case missingAttributeSeed
  case invalidAttributePassphrase
  case missingAttributePassphrase
  case invalidAttributeKeyLength
  case missingAttributeKeyLength
  case invalidAttributeBlockSize
  case missingAttributeBlockSize
  case invalidAttributeOutputSize
  case missingAttributeOutputSize
  case invalidAttributeRounds
  case missingAttributeRounds
  case invalidAlgorithmParms
  case missingAlgorithmParms
  case invalidAttributeLabel
  case missingAttributeLabel
  case invalidAttributeKeyType
  case missingAttributeKeyType
  case invalidAttributeMode
  case missingAttributeMode
  case invalidAttributeEffectiveBits
  case missingAttributeEffectiveBits
  case invalidAttributeStartDate
  case missingAttributeStartDate
  case invalidAttributeEndDate
  case missingAttributeEndDate
  case invalidAttributeVersion
  case missingAttributeVersion
  case invalidAttributePrime
  case missingAttributePrime
  case invalidAttributeBase
  case missingAttributeBase
  case invalidAttributeSubprime
  case missingAttributeSubprime
  case invalidAttributeIterationCount
  case missingAttributeIterationCount
  case invalidAttributeDLDBHandle
  case missingAttributeDLDBHandle
  case invalidAttributeAccessCredentials
  case missingAttributeAccessCredentials
  case invalidAttributePublicKeyFormat
  case missingAttributePublicKeyFormat
  case invalidAttributePrivateKeyFormat
  case missingAttributePrivateKeyFormat
  case invalidAttributeSymmetricKeyFormat
  case missingAttributeSymmetricKeyFormat
  case invalidAttributeWrappedKeyFormat
  case missingAttributeWrappedKeyFormat
  case stagedOperationInProgress
  case stagedOperationNotStarted
  case verifyFailed
  case querySizeUnknown
  case blockSizeMismatch
  case publicKeyInconsistent
  case deviceVerifyFailed
  case invalidLoginName
  case alreadyLoggedIn
  case invalidDigestAlgorithm
  case invalidCRLGroup
  case certificateCannotOperate
  case certificateExpired
  case certificateNotValidYet
  case certificateRevoked
  case certificateSuspended
  case insufficientCredentials
  case invalidAction
  case invalidAuthority
  case verifyActionFailed
  case invalidCertAuthority
  case invaldCRLAuthority
  case invalidCRLEncoding
  case invalidCRLType
  case invalidCRL
  case invalidFormType
  case invalidID
  case invalidIdentifier
  case invalidIndex
  case invalidPolicyIdentifiers
  case invalidTimeString
  case invalidReason
  case invalidRequestInputs
  case invalidResponseVector
  case invalidStopOnPolicy
  case invalidTuple
  case multipleValuesUnsupported
  case notTrusted
  case noDefaultAuthority
  case rejectedForm
  case requestLost
  case requestRejected
  case unsupportedAddressType
  case unsupportedService
  case invalidTupleGroup
  case invalidBaseACLs
  case invalidTupleCredendtials
  case invalidEncoding
  case invalidValidityPeriod
  case invalidRequestor
  case requestDescriptor
  case invalidBundleInfo
  case invalidCRLIndex
  case noFieldValues
  case unsupportedFieldFormat
  case unsupportedIndexInfo
  case unsupportedLocality
  case unsupportedNumAttributes
  case unsupportedNumIndexes
  case unsupportedNumRecordTypes
  case fieldSpecifiedMultiple
  case incompatibleFieldFormat
  case invalidParsingModule
  case databaseLocked
  case datastoreIsOpen
  case missingValue
  case unsupportedQueryLimits
  case unsupportedNumSelectionPreds
  case unsupportedOperator
  case invalidDBLocation
  case invalidAccessRequest
  case invalidIndexInfo
  case invalidNewOwner
  case invalidModifyMode
  case missingRequiredExtension
  case extendedKeyUsageNotCritical
  case timestampMissing
  case timestampInvalid
  case timestampNotTrusted
  case timestampServiceNotAvailable
  case timestampBadAlg
  case timestampBadRequest
  case timestampBadDataFormat
  case timestampTimeNotAvailable
  case timestampUnacceptedPolicy
  case timestampUnacceptedExtension
  case timestampAddInfoNotAvailable
  case timestampSystemFailure
  case signingTimeMissing
  case timestampRejection
  case timestampWaiting
  case timestampRevocationWarning
  case timestampRevocationNotification
  case unexpectedError
}
extension Status : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init(status: Darwin.OSStatus)
  public var description: Swift.String {
    get
  }
  public init?(rawValue: Darwin.OSStatus)
  public typealias RawValue = Darwin.OSStatus
  public var rawValue: Darwin.OSStatus {
    get
  }
}
extension Status : Foundation.CustomNSError {
  public static let errorDomain: Swift.String
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
extension HHPermission : CoreLocation.CLLocationManagerDelegate {
  @objc dynamic public func locationManager(_ manager: CoreLocation.CLLocationManager, didChangeAuthorization status: CoreLocation.CLAuthorizationStatus)
}
public let HHUUID: Swift.String
public let HHUserToken: Swift.String
public let HHInviteOrderKey: Swift.String
@_hasMissingDesignatedInitializers public class LoginManager {
  public static let `default`: HHSDKVideo.LoginManager
  public var mUUID: Swift.Int?
  public var mUserInfo: HHSDKVideo.HHUserModel?
  public func loadCache()
  public func removeCache()
  public func getUserInfo(token: Swift.String, success: ((Swift.String?) -> Swift.Void)? = nil, fail: ((Swift.String) -> Swift.Void)? = nil)
  public func getUserInfoRequest(success: ((Swift.String?) -> Swift.Void)? = nil, fail: ((Swift.String) -> Swift.Void)? = nil)
  public func convert2Model() -> Swift.String?
  public func getUserInfo() -> HHSDKVideo.HHUserModel?
  public func getCacheUserInfo() -> HHSDKVideo.HHUserModel?
  public func hasLoginData() -> Swift.Bool
  public func getUUID() -> Swift.Int?
  public func setUUID(uuid: Swift.Int)
  public func getToken() -> Swift.String?
  public func uuidStr() -> Swift.String?
  public func isMemeber() -> Swift.Bool
  public func isVIP() -> Swift.Bool
  public func getUpgradeVIPTips() -> Swift.String?
  public func isBuyProduct() -> Swift.Bool
  public func getMemberDes() -> Swift.String?
  public func isPhoneAccount() -> Swift.Bool
  public func getInviteOrder() -> Swift.String?
  public func setInviteOrder(orderId: Swift.String)
  public func clearInviteOrder()
  @objc deinit
}
public protocol MapContext {
}
final public class Map {
  final public let mappingType: HHSDKVideo.MappingType
  final public var JSON: [Swift.String : Any] {
    get
  }
  final public var isKeyPresent: Swift.Bool {
    get
  }
  final public var currentValue: Any? {
    get
  }
  final public var currentKey: Swift.String? {
    get
  }
  final public var nestedKeyDelimiter: Swift.String {
    get
  }
  final public var context: HHSDKVideo.MapContext?
  final public var shouldIncludeNilValues: Swift.Bool
  final public let toObject: Swift.Bool
  public init(mappingType: HHSDKVideo.MappingType, JSON: [Swift.String : Any], toObject: Swift.Bool = false, context: HHSDKVideo.MapContext? = nil, shouldIncludeNilValues: Swift.Bool = false)
  final public subscript(key: Swift.String) -> HHSDKVideo.Map {
    get
  }
  final public subscript(key: Swift.String, delimiter delimiter: Swift.String) -> HHSDKVideo.Map {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool) -> HHSDKVideo.Map {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool, delimiter delimiter: Swift.String) -> HHSDKVideo.Map {
    get
  }
  final public subscript(key: Swift.String, ignoreNil ignoreNil: Swift.Bool) -> HHSDKVideo.Map {
    get
  }
  final public subscript(key: Swift.String, delimiter delimiter: Swift.String, ignoreNil ignoreNil: Swift.Bool) -> HHSDKVideo.Map {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool, ignoreNil ignoreNil: Swift.Bool) -> HHSDKVideo.Map {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool?, delimiter delimiter: Swift.String, ignoreNil ignoreNil: Swift.Bool) -> HHSDKVideo.Map {
    get
  }
  final public func value<T>() -> T?
  @objc deinit
}
extension Map {
  final public func value<T>(_ key: Swift.String, default: T.Object, using transform: T) throws -> T.Object where T : HHSDKVideo.TransformType
  final public func value<T>(_ key: Swift.String, default: T) throws -> T
  final public func value<T>(_ key: Swift.String, default: [T]) -> [T] where T : HHSDKVideo.BaseMappable
  final public func value<T>(_ key: Swift.String, default: T) throws -> T where T : HHSDKVideo.BaseMappable
}
public struct MapError : Swift.Error {
  public var key: Swift.String?
  public var currentValue: Any?
  public var reason: Swift.String?
  public var file: Swift.StaticString?
  public var function: Swift.StaticString?
  public var line: Swift.UInt?
  public init(key: Swift.String?, currentValue: Any?, reason: Swift.String?, file: Swift.StaticString? = nil, function: Swift.StaticString? = nil, line: Swift.UInt? = nil)
}
extension MapError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public protocol BaseMappable {
  mutating func mapping(map: HHSDKVideo.Map)
}
public protocol Mappable : HHSDKVideo.BaseMappable {
  init?(map: HHSDKVideo.Map)
}
public protocol StaticMappable : HHSDKVideo.BaseMappable {
  static func objectForMapping(map: HHSDKVideo.Map) -> HHSDKVideo.BaseMappable?
}
extension Mappable {
  public init?(JSONString: Swift.String, context: HHSDKVideo.MapContext? = nil)
  public init?(JSON: [Swift.String : Any], context: HHSDKVideo.MapContext? = nil)
}
extension BaseMappable {
  public func toJSON() -> [Swift.String : Any]
  public func toJSONString(prettyPrint: Swift.Bool = false) -> Swift.String?
}
extension Array where Element : HHSDKVideo.BaseMappable {
  public init?(JSONString: Swift.String, context: HHSDKVideo.MapContext? = nil)
  public init(JSONArray: [[Swift.String : Any]], context: HHSDKVideo.MapContext? = nil)
  public func toJSON() -> [[Swift.String : Any]]
  public func toJSONString(prettyPrint: Swift.Bool = false) -> Swift.String?
}
extension Set where Element : HHSDKVideo.BaseMappable {
  public init?(JSONString: Swift.String, context: HHSDKVideo.MapContext? = nil)
  public init?(JSONArray: [[Swift.String : Any]], context: HHSDKVideo.MapContext? = nil)
  public func toJSON() -> [[Swift.String : Any]]
  public func toJSONString(prettyPrint: Swift.Bool = false) -> Swift.String?
}
public enum MappingType {
  case fromJSON
  case toJSON
  public static func == (a: HHSDKVideo.MappingType, b: HHSDKVideo.MappingType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class Mapper<N> where N : HHSDKVideo.BaseMappable {
  final public var context: HHSDKVideo.MapContext?
  final public var shouldIncludeNilValues: Swift.Bool
  public init(context: HHSDKVideo.MapContext? = nil, shouldIncludeNilValues: Swift.Bool = false)
  final public func map(JSONObject: Any?, toObject object: N) -> N
  final public func map(JSONString: Swift.String, toObject object: N) -> N
  final public func map(JSON: [Swift.String : Any], toObject object: N) -> N
  final public func map(JSONString: Swift.String) -> N?
  final public func map(JSONObject: Any?) -> N?
  final public func map(JSON: [Swift.String : Any]) -> N?
  final public func mapArray(JSONString: Swift.String) -> [N]?
  final public func mapArray(JSONObject: Any?) -> [N]?
  final public func mapArray(JSONArray: [[Swift.String : Any]]) -> [N]
  final public func mapDictionary(JSONString: Swift.String) -> [Swift.String : N]?
  final public func mapDictionary(JSONObject: Any?) -> [Swift.String : N]?
  final public func mapDictionary(JSON: [Swift.String : [Swift.String : Any]]) -> [Swift.String : N]?
  final public func mapDictionary(JSONObject: Any?, toDictionary dictionary: [Swift.String : N]) -> [Swift.String : N]
  final public func mapDictionary(JSON: [Swift.String : [Swift.String : Any]], toDictionary dictionary: [Swift.String : N]) -> [Swift.String : N]
  final public func mapDictionaryOfArrays(JSONObject: Any?) -> [Swift.String : [N]]?
  final public func mapDictionaryOfArrays(JSON: [Swift.String : [[Swift.String : Any]]]) -> [Swift.String : [N]]?
  final public func mapArrayOfArrays(JSONObject: Any?) -> [[N]]?
  public static func parseJSONStringIntoDictionary(JSONString: Swift.String) -> [Swift.String : Any]?
  public static func parseJSONString(JSONString: Swift.String) -> Any?
  @objc deinit
}
extension Mapper {
  final public func map(JSONfile: Swift.String) -> N?
  final public func mapArray(JSONfile: Swift.String) -> [N]?
}
extension Mapper {
  final public func toJSON(_ object: N) -> [Swift.String : Any]
  final public func toJSONArray(_ array: [N]) -> [[Swift.String : Any]]
  final public func toJSONDictionary(_ dictionary: [Swift.String : N]) -> [Swift.String : [Swift.String : Any]]
  final public func toJSONDictionaryOfArrays(_ dictionary: [Swift.String : [N]]) -> [Swift.String : [[Swift.String : Any]]]
  final public func toJSONString(_ object: N, prettyPrint: Swift.Bool = false) -> Swift.String?
  final public func toJSONString(_ array: [N], prettyPrint: Swift.Bool = false) -> Swift.String?
  public static func toJSONString(_ JSONObject: Any, prettyPrint: Swift.Bool) -> Swift.String?
  public static func toJSONData(_ JSONObject: Any, options: Foundation.JSONSerialization.WritingOptions) -> Foundation.Data?
}
extension Mapper where N : Swift.Hashable {
  final public func mapSet(JSONString: Swift.String) -> Swift.Set<N>?
  final public func mapSet(JSONObject: Any?) -> Swift.Set<N>?
  final public func mapSet(JSONArray: [[Swift.String : Any]]) -> Swift.Set<N>
  final public func toJSONSet(_ set: Swift.Set<N>) -> [[Swift.String : Any]]
  final public func toJSONString(_ set: Swift.Set<N>, prettyPrint: Swift.Bool = false) -> Swift.String?
}
final public class MD5 {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension MD5 : HHSDKVideo.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
public struct NotifyInfo {
  public init()
  public var fromAccountId: Swift.String?
  public var requestId: Swift.String?
  public var channelId: Swift.String?
  public var customInfo: Swift.String?
}
open class NSDecimalNumberTransform : HHSDKVideo.TransformType {
  public typealias Object = Foundation.NSDecimalNumber
  public typealias JSON = Swift.String
  public init()
  open func transformFromJSON(_ value: Any?) -> Foundation.NSDecimalNumber?
  open func transformToJSON(_ value: Foundation.NSDecimalNumber?) -> Swift.String?
  @objc deinit
}
final public class OCB : HHSDKVideo.BlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: HHSDKVideo.OCB.Mode, b: HHSDKVideo.OCB.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: HHSDKVideo.BlockModeOption
  public enum Error : Swift.Error {
    case invalidNonce
    case fail
    public static func == (a: HHSDKVideo.OCB.Error, b: HHSDKVideo.OCB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(nonce N: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: HHSDKVideo.OCB.Mode = .detached)
  convenience public init(nonce N: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: HHSDKVideo.OCB.Mode = .detached)
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping HHSDKVideo.CipherOperationOnBlock, encryptionOperation: @escaping HHSDKVideo.CipherOperationOnBlock) throws -> HHSDKVideo.CipherModeWorker
  @objc deinit
}
public struct OFB : HHSDKVideo.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: HHSDKVideo.OFB.Error, b: HHSDKVideo.OFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: HHSDKVideo.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping HHSDKVideo.CipherOperationOnBlock, encryptionOperation: @escaping HHSDKVideo.CipherOperationOnBlock) throws -> HHSDKVideo.CipherModeWorker
}
infix operator <- : DefaultPrecedence
infix operator >>> : DefaultPrecedence
public func <- <T>(left: inout T, right: HHSDKVideo.Map)
public func >>> <T>(left: T, right: HHSDKVideo.Map)
public func <- <T>(left: inout T?, right: HHSDKVideo.Map)
public func >>> <T>(left: T?, right: HHSDKVideo.Map)
public func <- <T>(left: inout T, right: HHSDKVideo.Map) where T : HHSDKVideo.BaseMappable
public func >>> <T>(left: T, right: HHSDKVideo.Map) where T : HHSDKVideo.BaseMappable
public func <- <T>(left: inout T?, right: HHSDKVideo.Map) where T : HHSDKVideo.BaseMappable
public func >>> <T>(left: T?, right: HHSDKVideo.Map) where T : HHSDKVideo.BaseMappable
public func <- <T>(left: inout Swift.Dictionary<Swift.String, T>, right: HHSDKVideo.Map) where T : HHSDKVideo.BaseMappable
public func >>> <T>(left: Swift.Dictionary<Swift.String, T>, right: HHSDKVideo.Map) where T : HHSDKVideo.BaseMappable
public func <- <T>(left: inout Swift.Dictionary<Swift.String, T>?, right: HHSDKVideo.Map) where T : HHSDKVideo.BaseMappable
public func >>> <T>(left: Swift.Dictionary<Swift.String, T>?, right: HHSDKVideo.Map) where T : HHSDKVideo.BaseMappable
public func <- <T>(left: inout Swift.Dictionary<Swift.String, [T]>, right: HHSDKVideo.Map) where T : HHSDKVideo.BaseMappable
public func >>> <T>(left: Swift.Dictionary<Swift.String, [T]>, right: HHSDKVideo.Map) where T : HHSDKVideo.BaseMappable
public func <- <T>(left: inout Swift.Dictionary<Swift.String, [T]>?, right: HHSDKVideo.Map) where T : HHSDKVideo.BaseMappable
public func >>> <T>(left: Swift.Dictionary<Swift.String, [T]>?, right: HHSDKVideo.Map) where T : HHSDKVideo.BaseMappable
public func <- <T>(left: inout Swift.Array<T>, right: HHSDKVideo.Map) where T : HHSDKVideo.BaseMappable
public func >>> <T>(left: Swift.Array<T>, right: HHSDKVideo.Map) where T : HHSDKVideo.BaseMappable
public func <- <T>(left: inout Swift.Array<T>?, right: HHSDKVideo.Map) where T : HHSDKVideo.BaseMappable
public func >>> <T>(left: Swift.Array<T>?, right: HHSDKVideo.Map) where T : HHSDKVideo.BaseMappable
public func <- <T>(left: inout Swift.Array<Swift.Array<T>>, right: HHSDKVideo.Map) where T : HHSDKVideo.BaseMappable
public func >>> <T>(left: Swift.Array<Swift.Array<T>>, right: HHSDKVideo.Map) where T : HHSDKVideo.BaseMappable
public func <- <T>(left: inout Swift.Array<Swift.Array<T>>?, right: HHSDKVideo.Map) where T : HHSDKVideo.BaseMappable
public func >>> <T>(left: Swift.Array<Swift.Array<T>>?, right: HHSDKVideo.Map) where T : HHSDKVideo.BaseMappable
public func <- <T>(left: inout Swift.Set<T>, right: HHSDKVideo.Map) where T : HHSDKVideo.BaseMappable, T : Swift.Hashable
public func >>> <T>(left: Swift.Set<T>, right: HHSDKVideo.Map) where T : HHSDKVideo.BaseMappable, T : Swift.Hashable
public func <- <T>(left: inout Swift.Set<T>?, right: HHSDKVideo.Map) where T : HHSDKVideo.BaseMappable, T : Swift.Hashable
public func >>> <T>(left: Swift.Set<T>?, right: HHSDKVideo.Map) where T : HHSDKVideo.BaseMappable, T : Swift.Hashable
public struct OrderModel : HHSDKVideo.Mappable {
  public var orderid: Swift.String?
  public var price: Swift.Float?
  public var buyServiceName: Swift.String?
  public var expertId: Swift.String?
  public var expertName: Swift.String?
  public var patientName: Swift.String?
  public init?(map: HHSDKVideo.Map)
  public mutating func mapping(map: HHSDKVideo.Map)
}
public protocol PaddingProtocol {
  func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
}
public enum Padding : HHSDKVideo.PaddingProtocol {
  case noPadding, zeroPadding, pkcs7, pkcs5, iso78164
  public func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  public func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
  public static func == (a: HHSDKVideo.Padding, b: HHSDKVideo.Padding) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension PKCS5 {
  public struct PBKDF1 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: HHSDKVideo.PKCS5.PBKDF1.Error, b: HHSDKVideo.PKCS5.PBKDF1.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum Variant {
      case md5, sha1
      public static func == (a: HHSDKVideo.PKCS5.PBKDF1.Variant, b: HHSDKVideo.PKCS5.PBKDF1.Variant) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, variant: HHSDKVideo.PKCS5.PBKDF1.Variant = .sha1, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil) throws
    public func calculate() -> Swift.Array<Swift.UInt8>
  }
}
extension PKCS5 {
  public struct PBKDF2 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: HHSDKVideo.PKCS5.PBKDF2.Error, b: HHSDKVideo.PKCS5.PBKDF2.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil, variant: HHSDKVideo.HMAC.Variant = .sha256) throws
    public func calculate() throws -> Swift.Array<Swift.UInt8>
  }
}
public struct PCBC : HHSDKVideo.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: HHSDKVideo.PCBC.Error, b: HHSDKVideo.PCBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: HHSDKVideo.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping HHSDKVideo.CipherOperationOnBlock, encryptionOperation: @escaping HHSDKVideo.CipherOperationOnBlock) throws -> HHSDKVideo.CipherModeWorker
}
@objc @_hasMissingDesignatedInitializers public class HHPermission : ObjectiveC.NSObject {
  public static let locationAlways: HHSDKVideo.HHPermission
  public static let locationWhenInUse: HHSDKVideo.HHPermission
  public static let microphone: HHSDKVideo.HHPermission
  public static let camera: HHSDKVideo.HHPermission
  public static let photos: HHSDKVideo.HHPermission
  final public let type: HHSDKVideo.HHBasePermissionType
  public var status: HHSDKVideo.PermissionStatus {
    get
  }
  public var presentPrePermissionAlert: Swift.Bool
  public var prePermissionAlert: HHSDKVideo.PermissionAlert {
    get
    set
  }
  public var presentDeniedAlert: Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
extension HHPermission {
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc override dynamic public var debugDescription: Swift.String {
    @objc get
  }
}
@_hasMissingDesignatedInitializers public class PermissionAlert {
  @objc deinit
}
public enum PermissionStatus : Swift.String {
  case authorized
  case denied
  case disabled
  case notDetermined
  case limited
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension PermissionStatus : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@objc public enum HHBasePermissionType : Swift.Int {
  case locationAlways
  case locationWhenInUse
  case microphone
  case camera
  case photos
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension HHBasePermissionType : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class PhotoPickerConfig {
  public static let `default`: HHSDKVideo.PhotoPickerConfig
  public var miniPicTip: Swift.Bool
  public var mMaxSelectCount: Swift.Int
  public var mDetailColumnCount: Swift.Int
  @objc deinit
}
public enum PKCS5 {
}
public enum PKCS7 {
}
final public class Poly1305 : HHSDKVideo.CryptoAuthenticator {
  public enum Error : Swift.Error {
    case authenticateError
    public static func == (a: HHSDKVideo.Poly1305.Error, b: HHSDKVideo.Poly1305.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
@_hasMissingDesignatedInitializers public class PostBodyEncoding {
  @objc deinit
}
final public class Rabbit {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    public static func == (a: HHSDKVideo.Rabbit.Error, b: HHSDKVideo.Rabbit.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let ivSize: Swift.Int
  public static let keySize: Swift.Int
  public static let blockSize: Swift.Int
  final public var keySize: Swift.Int {
    get
  }
  convenience public init(key: Swift.Array<Swift.UInt8>) throws
  public init(key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>?) throws
  @objc deinit
}
extension Rabbit : HHSDKVideo.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension Rabbit {
  convenience public init(key: Swift.String) throws
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
public enum ReachabilityError : Swift.Error {
  case FailedToCreateWithAddress(Darwin.sockaddr_in)
  case FailedToCreateWithHostname(Swift.String)
  case UnableToSetCallback
  case UnableToSetDispatchQueue
}
public let ReachabilityChangedNotification: Foundation.NSNotification.Name
public class Reachability {
  public typealias NetworkReachable = (HHSDKVideo.Reachability) -> ()
  public typealias NetworkUnreachable = (HHSDKVideo.Reachability) -> ()
  public enum NetworkStatus : Swift.CustomStringConvertible {
    case notReachable, reachableViaWiFi, reachableViaWWAN
    public var description: Swift.String {
      get
    }
    public static func == (a: HHSDKVideo.Reachability.NetworkStatus, b: HHSDKVideo.Reachability.NetworkStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var whenReachable: HHSDKVideo.Reachability.NetworkReachable?
  public var whenUnreachable: HHSDKVideo.Reachability.NetworkUnreachable?
  public var reachableOnWWAN: Swift.Bool
  public var currentReachabilityString: Swift.String {
    get
  }
  public var currentReachabilityStatus: HHSDKVideo.Reachability.NetworkStatus {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability)
  convenience public init?(hostname: Swift.String)
  convenience public init?()
  @objc deinit
}
extension Reachability {
  public func startNotifier() throws
  public func stopNotifier()
  public var isReachable: Swift.Bool {
    get
  }
  public var isReachableViaWWAN: Swift.Bool {
    get
  }
  public var isReachableViaWiFi: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
public enum RecordImgType : Swift.Int {
  case medic
  case check
  case yingXiang
  case video
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct RemoteData : HHSDKVideo.Mappable {
  public var changeDoctorTime: Swift.Int
  public var appTVConfig: Swift.String?
  public var appJsonConfig: Swift.String?
  public init?(map: HHSDKVideo.Map)
  public mutating func mapping(map: HHSDKVideo.Map)
}
final public class Scrypt {
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, dkLen: Swift.Int, N: Swift.Int, r: Swift.Int, p: Swift.Int) throws
  final public func calculate() throws -> [Swift.UInt8]
  @objc deinit
}
public struct SDKConfigModel : HHSDKVideo.Mappable {
  public var cardIdActiveShow: Swift.Int
  public var changeDoctorTime: Swift.Int?
  public init?(map: HHSDKVideo.Map)
  public mutating func mapping(map: HHSDKVideo.Map)
}
final public class SHA1 {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension SHA1 : HHSDKVideo.Updatable {
  @discardableResult
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
final public class SHA2 {
  public enum Variant : Swift.RawRepresentable {
    case sha224, sha256, sha384, sha512
    public var digestLength: Swift.Int {
      get
    }
    public var blockSize: Swift.Int {
      get
    }
    public typealias RawValue = Swift.Int
    public var rawValue: HHSDKVideo.SHA2.Variant.RawValue {
      get
    }
    public init?(rawValue: HHSDKVideo.SHA2.Variant.RawValue)
  }
  public init(variant: HHSDKVideo.SHA2.Variant)
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension SHA2 : HHSDKVideo.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
final public class SHA3 {
  final public let blockSize: Swift.Int
  final public let digestLength: Swift.Int
  final public let markByte: Swift.UInt8
  public enum Variant {
    case sha224, sha256, sha384, sha512, keccak224, keccak256, keccak384, keccak512
    public var outputLength: Swift.Int {
      get
    }
    public static func == (a: HHSDKVideo.SHA3.Variant, b: HHSDKVideo.SHA3.Variant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(variant: HHSDKVideo.SHA3.Variant)
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension SHA3 : HHSDKVideo.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
extension String {
  public var bytes: Swift.Array<Swift.UInt8> {
    get
  }
  public func md5() -> Swift.String
  public func sha1() -> Swift.String
  public func sha224() -> Swift.String
  public func sha256() -> Swift.String
  public func sha384() -> Swift.String
  public func sha512() -> Swift.String
  public func sha3(_ variant: HHSDKVideo.SHA3.Variant) -> Swift.String
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.String
  public func encrypt(cipher: HHSDKVideo.Cipher) throws -> Swift.String
  public func encryptToBase64(cipher: HHSDKVideo.Cipher) throws -> Swift.String?
  public func authenticate<A>(with authenticator: A) throws -> Swift.String where A : HHSDKVideo.CryptoAuthenticator
}
extension String {
  public func decryptBase64ToString(cipher: HHSDKVideo.Cipher) throws -> Swift.String
  public func decryptBase64(cipher: HHSDKVideo.Cipher) throws -> Swift.Array<Swift.UInt8>
}
@_hasMissingDesignatedInitializers final public class SwiftEntryKit {
  public enum EntryDismissalDescriptor {
    case specific(entryName: Swift.String)
    case prioritizedLowerOrEqualTo(priority: HHSDKVideo.EKAttributes.Precedence.Priority)
    case enqueued
    case all
    case displayed
  }
  public enum RollbackWindow {
    case main
    case custom(window: UIKit.UIWindow)
  }
  public typealias DismissCompletionHandler = () -> Swift.Void
  final public class var window: UIKit.UIWindow? {
    get
  }
  final public class var isCurrentlyDisplaying: Swift.Bool {
    get
  }
  final public class func isCurrentlyDisplaying(entryNamed name: Swift.String? = nil) -> Swift.Bool
  final public class var isQueueEmpty: Swift.Bool {
    get
  }
  final public class func queueContains(entryNamed name: Swift.String? = nil) -> Swift.Bool
  final public class func display(entry view: UIKit.UIView, using attributes: HHSDKVideo.EKAttributes, presentInsideKeyWindow: Swift.Bool = false, rollbackWindow: HHSDKVideo.SwiftEntryKit.RollbackWindow = .main)
  final public class func display(entry viewController: UIKit.UIViewController, using attributes: HHSDKVideo.EKAttributes, presentInsideKeyWindow: Swift.Bool = false, rollbackWindow: HHSDKVideo.SwiftEntryKit.RollbackWindow = .main)
  final public class func transform(to view: UIKit.UIView)
  final public class func dismiss(_ descriptor: HHSDKVideo.SwiftEntryKit.EntryDismissalDescriptor = .displayed, with completion: HHSDKVideo.SwiftEntryKit.DismissCompletionHandler? = nil)
  final public class func layoutIfNeeded()
  @objc deinit
}
open class TransformOf<ObjectType, JSONType> : HHSDKVideo.TransformType {
  public typealias Object = ObjectType
  public typealias JSON = JSONType
  public init(fromJSON: @escaping (JSONType?) -> ObjectType?, toJSON: @escaping (ObjectType?) -> JSONType?)
  open func transformFromJSON(_ value: Any?) -> ObjectType?
  open func transformToJSON(_ value: ObjectType?) -> JSONType?
  @objc deinit
}
public func <- <Transform>(left: inout Transform.Object, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType
public func >>> <Transform>(left: Transform.Object, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType
public func <- <Transform>(left: inout Transform.Object?, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType
public func >>> <Transform>(left: Transform.Object?, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType
public func <- <Transform>(left: inout [Transform.Object], right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType
public func >>> <Transform>(left: [Transform.Object], right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType
public func <- <Transform>(left: inout [Transform.Object]?, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType
public func >>> <Transform>(left: [Transform.Object]?, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType
public func <- <Transform>(left: inout [Swift.String : Transform.Object], right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType
public func >>> <Transform>(left: [Swift.String : Transform.Object], right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType
public func <- <Transform>(left: inout [Swift.String : Transform.Object]?, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType
public func >>> <Transform>(left: [Swift.String : Transform.Object]?, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType
public func <- <Transform>(left: inout Transform.Object, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType, Transform.Object : HHSDKVideo.BaseMappable
public func >>> <Transform>(left: Transform.Object, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType, Transform.Object : HHSDKVideo.BaseMappable
public func <- <Transform>(left: inout Transform.Object?, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType, Transform.Object : HHSDKVideo.BaseMappable
public func >>> <Transform>(left: Transform.Object?, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType, Transform.Object : HHSDKVideo.BaseMappable
public func <- <Transform>(left: inout Swift.Dictionary<Swift.String, Transform.Object>, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType, Transform.Object : HHSDKVideo.BaseMappable
public func >>> <Transform>(left: Swift.Dictionary<Swift.String, Transform.Object>, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType, Transform.Object : HHSDKVideo.BaseMappable
public func <- <Transform>(left: inout Swift.Dictionary<Swift.String, Transform.Object>?, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType, Transform.Object : HHSDKVideo.BaseMappable
public func >>> <Transform>(left: Swift.Dictionary<Swift.String, Transform.Object>?, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType, Transform.Object : HHSDKVideo.BaseMappable
public func <- <Transform>(left: inout Swift.Dictionary<Swift.String, [Transform.Object]>, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType, Transform.Object : HHSDKVideo.BaseMappable
public func >>> <Transform>(left: Swift.Dictionary<Swift.String, [Transform.Object]>, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType, Transform.Object : HHSDKVideo.BaseMappable
public func <- <Transform>(left: inout Swift.Dictionary<Swift.String, [Transform.Object]>?, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType, Transform.Object : HHSDKVideo.BaseMappable
public func >>> <Transform>(left: Swift.Dictionary<Swift.String, [Transform.Object]>?, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType, Transform.Object : HHSDKVideo.BaseMappable
public func <- <Transform>(left: inout Swift.Array<Transform.Object>, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType, Transform.Object : HHSDKVideo.BaseMappable
public func >>> <Transform>(left: Swift.Array<Transform.Object>, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType, Transform.Object : HHSDKVideo.BaseMappable
public func <- <Transform>(left: inout Swift.Array<Transform.Object>?, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType, Transform.Object : HHSDKVideo.BaseMappable
public func >>> <Transform>(left: Swift.Array<Transform.Object>?, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType, Transform.Object : HHSDKVideo.BaseMappable
public func <- <Transform>(left: inout [[Transform.Object]], right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType
public func >>> <Transform>(left: [[Transform.Object]], right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType
public func <- <Transform>(left: inout [[Transform.Object]]?, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType
public func >>> <Transform>(left: [[Transform.Object]]?, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType
public func <- <Transform>(left: inout Swift.Set<Transform.Object>, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType, Transform.Object : HHSDKVideo.BaseMappable, Transform.Object : Swift.Hashable
public func >>> <Transform>(left: Swift.Set<Transform.Object>, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType, Transform.Object : HHSDKVideo.BaseMappable, Transform.Object : Swift.Hashable
public func <- <Transform>(left: inout Swift.Set<Transform.Object>?, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType, Transform.Object : HHSDKVideo.BaseMappable, Transform.Object : Swift.Hashable
public func >>> <Transform>(left: Swift.Set<Transform.Object>?, right: (HHSDKVideo.Map, Transform)) where Transform : HHSDKVideo.TransformType, Transform.Object : HHSDKVideo.BaseMappable, Transform.Object : Swift.Hashable
public protocol TransformType {
  associatedtype Object
  associatedtype JSON
  func transformFromJSON(_ value: Any?) -> Self.Object?
  func transformToJSON(_ value: Self.Object?) -> Self.JSON?
}
extension UIImage {
  public class func gifImageWithData(_ data: Foundation.Data) -> UIKit.UIImage?
  public class func gifImageWithURL(_ gifUrl: Swift.String) -> UIKit.UIImage?
  public class func gifImageWithName(_ name: Swift.String) -> UIKit.UIImage?
}
public protocol _UInt8Type {
}
extension UInt8 : HHSDKVideo._UInt8Type {
}
extension UInt8 {
  public func bits() -> [HHSDKVideo.Bit]
  public func bits() -> Swift.String
}
public protocol Updatable {
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
extension Updatable {
  public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
  public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
  public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public mutating func finish() throws -> Swift.Array<Swift.UInt8>
  public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func finish(output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
open class URLTransform : HHSDKVideo.TransformType {
  public typealias Object = Foundation.URL
  public typealias JSON = Swift.String
  public init(shouldEncodeURLString: Swift.Bool = false, allowedCharacterSet: Foundation.CharacterSet = .urlQueryAllowed)
  open func transformFromJSON(_ value: Any?) -> Foundation.URL?
  open func transformToJSON(_ value: Foundation.URL?) -> Swift.String?
  @objc deinit
}
public struct UserApi {
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class VCManager : ObjectiveC.NSObject {
  public static let `default`: HHSDKVideo.VCManager
  public var waitModel: HHSDKVideo.HHWaitDoctorModel?
  @objc deinit
}
extension VCManager {
  public func onReceiveCall(callee: Swift.String, caller: Swift.String, orderId: Swift.String)
  public func isInBusy() -> Swift.Bool
}
extension VCManager {
  public func onReceiveInvite(docModel: HHSDKVideo.HHInviteDocModel)
  public static func onUserReject(_ fromUuid: Swift.String)
  public static func onCancelInvite(_ fromUuid: Swift.String)
  public static func changeVideo(_ isVoice: Swift.Bool)
}
extension VCManager {
  public func showEduBoard(groupId: Swift.String, orderId: Swift.String, isLong: Swift.Bool, fileUrl: Swift.String)
  public func closeEduBoard()
}
public struct VideoApi {
}
public enum HHIMCmd : Swift.String {
  case audio
  case video
  case closeVideo
  case openVideo
  case transfor
  case accept
  case call
  case reject
  case cancelCall
  case pcCancel
  case phoneCall
  case busy
  case waiting
  case waitingTip
  case agentTrans
  case web_transform
  case callWeb
  case SWITCH_TO_CAMERA_wmp
  case cancelCallWeb
  case call_invite
  case reject_invite
  case cancel_invite
  case exit_camera
  case enter_camera
  case conference_begin
  case conference_end
  case user_certification
  case cancel_user_certification
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public class WeakArray<T> {
  public func add(_ delegate: T)
  public func remove(_ delegate: T)
  public func excute(_ block: @escaping ((T?) -> Swift.Void))
  public init()
  @objc deinit
}
@objc public class ZLAlbumListModel : ObjectiveC.NSObject {
  final public let title: Swift.String
  public var count: Swift.Int {
    get
  }
  public var result: Photos.PHFetchResult<Photos.PHAsset>
  final public let collection: Photos.PHAssetCollection
  final public let option: Photos.PHFetchOptions
  final public let isCameraRoll: Swift.Bool
  public var headImageAsset: Photos.PHAsset? {
    get
  }
  public var models: [HHSDKVideo.ZLPhotoModel]
  public init(title: Swift.String, result: Photos.PHFetchResult<Photos.PHAsset>, collection: Photos.PHAssetCollection, option: Photos.PHFetchOptions, isCameraRoll: Swift.Bool)
  public func refetchPhotos()
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class ZLCameraConfiguration : ObjectiveC.NSObject {
  @objc public enum CaptureSessionPreset : Swift.Int {
    case cif352x288
    case vga640x480
    case hd1280x720
    case hd1920x1080
    case hd4K3840x2160
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc public enum FocusMode : Swift.Int {
    case autoFocus
    case continuousAutoFocus
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc public enum ExposureMode : Swift.Int {
    case autoExpose
    case continuousAutoExposure
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc public enum FlashMode : Swift.Int {
    case auto
    case on
    case off
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc public enum VideoExportType : Swift.Int {
    case mov
    case mp4
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc public var sessionPreset: HHSDKVideo.ZLCameraConfiguration.CaptureSessionPreset
  @objc public var focusMode: HHSDKVideo.ZLCameraConfiguration.FocusMode
  @objc public var exposureMode: HHSDKVideo.ZLCameraConfiguration.ExposureMode
  @objc public var flashMode: HHSDKVideo.ZLCameraConfiguration.FlashMode
  @objc public var videoExportType: HHSDKVideo.ZLCameraConfiguration.VideoExportType
  @objc override dynamic public init()
  @objc deinit
}
extension ZLCameraConfiguration {
  @discardableResult
  public func sessionPreset(_ sessionPreset: HHSDKVideo.ZLCameraConfiguration.CaptureSessionPreset) -> HHSDKVideo.ZLCameraConfiguration
  @discardableResult
  public func focusMode(_ mode: HHSDKVideo.ZLCameraConfiguration.FocusMode) -> HHSDKVideo.ZLCameraConfiguration
  @discardableResult
  public func exposureMode(_ mode: HHSDKVideo.ZLCameraConfiguration.ExposureMode) -> HHSDKVideo.ZLCameraConfiguration
  @discardableResult
  public func flashMode(_ mode: HHSDKVideo.ZLCameraConfiguration.FlashMode) -> HHSDKVideo.ZLCameraConfiguration
  @discardableResult
  public func videoExportType(_ type: HHSDKVideo.ZLCameraConfiguration.VideoExportType) -> HHSDKVideo.ZLCameraConfiguration
}
@objc open class ZLCustomCamera : UIKit.UIViewController, QuartzCore.CAAnimationDelegate {
  @objc public var takeDoneBlock: ((UIKit.UIImage?, Foundation.URL?) -> Swift.Void)?
  @objc public var cancelBlock: (() -> Swift.Void)?
  public var tipsLabel: UIKit.UILabel {
    get
    set
  }
  public var bottomView: UIKit.UIView {
    get
    set
  }
  public var largeCircleView: UIKit.UIVisualEffectView {
    get
    set
  }
  public var smallCircleView: UIKit.UIView {
    get
    set
  }
  public var animateLayer: QuartzCore.CAShapeLayer {
    get
    set
  }
  public var retakeBtn: HHSDKVideo.ZLEnlargeButton {
    get
    set
  }
  public var doneBtn: UIKit.UIButton {
    get
    set
  }
  public var dismissBtn: HHSDKVideo.ZLEnlargeButton {
    get
    set
  }
  public var switchCameraBtn: HHSDKVideo.ZLEnlargeButton {
    get
    set
  }
  public var focusCursorView: UIKit.UIImageView {
    get
    set
  }
  public var takedImageView: UIKit.UIImageView {
    get
    set
  }
  @objc override dynamic public var supportedInterfaceOrientations: UIKit.UIInterfaceOrientationMask {
    @objc get
  }
  @objc override dynamic public var prefersStatusBarHidden: Swift.Bool {
    @objc get
  }
  @objc deinit
  @objc dynamic public init()
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc override dynamic open func viewDidLoad()
  @objc override dynamic open func viewWillAppear(_ animated: Swift.Bool)
  @objc override dynamic open func viewDidAppear(_ animated: Swift.Bool)
  @objc override dynamic open func viewWillDisappear(_ animated: Swift.Bool)
  @objc override dynamic open func viewDidDisappear(_ animated: Swift.Bool)
  @objc override dynamic open func viewDidLayoutSubviews()
  @objc public func animationDidStop(_ anim: QuartzCore.CAAnimation, finished flag: Swift.Bool)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
}
extension ZLCustomCamera : AVFoundation.AVCapturePhotoCaptureDelegate {
  @objc dynamic public func photoOutput(_ output: AVFoundation.AVCapturePhotoOutput, willCapturePhotoFor resolvedSettings: AVFoundation.AVCaptureResolvedPhotoSettings)
  @objc dynamic public func photoOutput(_ output: AVFoundation.AVCapturePhotoOutput, didFinishProcessingPhoto photoSampleBuffer: CoreMedia.CMSampleBuffer?, previewPhoto previewPhotoSampleBuffer: CoreMedia.CMSampleBuffer?, resolvedSettings: AVFoundation.AVCaptureResolvedPhotoSettings, bracketSettings: AVFoundation.AVCaptureBracketedStillImageSettings?, error: Swift.Error?)
}
extension ZLCustomCamera : AVFoundation.AVCaptureFileOutputRecordingDelegate {
  @objc dynamic public func fileOutput(_ output: AVFoundation.AVCaptureFileOutput, didStartRecordingTo fileURL: Foundation.URL, from connections: [AVFoundation.AVCaptureConnection])
  @objc dynamic public func fileOutput(_ output: AVFoundation.AVCaptureFileOutput, didFinishRecordingTo outputFileURL: Foundation.URL, from connections: [AVFoundation.AVCaptureConnection], error: Swift.Error?)
}
extension ZLCustomCamera : UIKit.UIGestureRecognizerDelegate {
  @objc dynamic public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
}
@objc public protocol ZLImageStickerContainerDelegate {
  @objc var selectImageBlock: ((UIKit.UIImage) -> Swift.Void)? { get set }
  @objc var hideBlock: (() -> Swift.Void)? { get set }
  @objc func show(in view: UIKit.UIView)
}
@objc @_inheritsConvenienceInitializers public class ZLEditImageConfiguration : ObjectiveC.NSObject {
  @objc public enum EditTool : Swift.Int, Swift.CaseIterable {
    case draw
    case clip
    case imageSticker
    case textSticker
    case mosaic
    case filter
    case adjust
    public init?(rawValue: Swift.Int)
    public typealias AllCases = [HHSDKVideo.ZLEditImageConfiguration.EditTool]
    public typealias RawValue = Swift.Int
    public static var allCases: [HHSDKVideo.ZLEditImageConfiguration.EditTool] {
      get
    }
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc public enum AdjustTool : Swift.Int, Swift.CaseIterable {
    case brightness
    case contrast
    case saturation
    public init?(rawValue: Swift.Int)
    public typealias AllCases = [HHSDKVideo.ZLEditImageConfiguration.AdjustTool]
    public typealias RawValue = Swift.Int
    public static var allCases: [HHSDKVideo.ZLEditImageConfiguration.AdjustTool] {
      get
    }
    public var rawValue: Swift.Int {
      get
    }
  }
  public var tools: [HHSDKVideo.ZLEditImageConfiguration.EditTool] {
    get
    set
  }
  @objc public var tools_objc: [Swift.Int] {
    @objc get
    @objc set
  }
  @objc public var drawColors: [UIKit.UIColor] {
    @objc get
    @objc set
  }
  @objc public var defaultDrawColor: UIKit.UIColor
  @objc public var clipRatios: [HHSDKVideo.ZLImageClipRatio] {
    @objc get
    @objc set
  }
  @objc public var textStickerTextColors: [UIKit.UIColor] {
    @objc get
    @objc set
  }
  @objc public var textStickerDefaultTextColor: UIKit.UIColor
  @objc public var filters: [HHSDKVideo.ZLFilter] {
    @objc get
    @objc set
  }
  @objc public var imageStickerContainerView: (UIKit.UIView & HHSDKVideo.ZLImageStickerContainerDelegate)?
  public var adjustTools: [HHSDKVideo.ZLEditImageConfiguration.AdjustTool] {
    get
    set
  }
  @objc public var adjustTools_objc: [Swift.Int] {
    @objc get
    @objc set
  }
  @objc public var impactFeedbackWhenAdjustSliderValueIsZero: Swift.Bool
  @objc public var impactFeedbackStyle: UIKit.UIImpactFeedbackGenerator.FeedbackStyle
  @objc override dynamic public init()
  @objc deinit
}
extension ZLEditImageConfiguration {
  @discardableResult
  public func tools(_ tools: [HHSDKVideo.ZLEditImageConfiguration.EditTool]) -> HHSDKVideo.ZLEditImageConfiguration
  @discardableResult
  public func drawColors(_ colors: [UIKit.UIColor]) -> HHSDKVideo.ZLEditImageConfiguration
  public func defaultDrawColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLEditImageConfiguration
  @discardableResult
  public func clipRatios(_ ratios: [HHSDKVideo.ZLImageClipRatio]) -> HHSDKVideo.ZLEditImageConfiguration
  @discardableResult
  public func textStickerTextColors(_ colors: [UIKit.UIColor]) -> HHSDKVideo.ZLEditImageConfiguration
  @discardableResult
  public func textStickerDefaultTextColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLEditImageConfiguration
  @discardableResult
  public func filters(_ filters: [HHSDKVideo.ZLFilter]) -> HHSDKVideo.ZLEditImageConfiguration
  @discardableResult
  public func imageStickerContainerView(_ view: (UIKit.UIView & HHSDKVideo.ZLImageStickerContainerDelegate)?) -> HHSDKVideo.ZLEditImageConfiguration
  @discardableResult
  public func adjustTools(_ tools: [HHSDKVideo.ZLEditImageConfiguration.AdjustTool]) -> HHSDKVideo.ZLEditImageConfiguration
  @discardableResult
  public func impactFeedbackWhenAdjustSliderValueIsZero(_ value: Swift.Bool) -> HHSDKVideo.ZLEditImageConfiguration
  @discardableResult
  public func impactFeedbackStyle(_ style: UIKit.UIImpactFeedbackGenerator.FeedbackStyle) -> HHSDKVideo.ZLEditImageConfiguration
}
@objc public class ZLImageClipRatio : ObjectiveC.NSObject {
  public var title: Swift.String
  final public let whRatio: CoreGraphics.CGFloat
  @objc public init(title: Swift.String, whRatio: CoreGraphics.CGFloat, isCircle: Swift.Bool = false)
  @objc override dynamic public init()
  @objc deinit
}
extension ZLImageClipRatio {
  @objc public static let custom: HHSDKVideo.ZLImageClipRatio
  @objc public static let circle: HHSDKVideo.ZLImageClipRatio
  @objc public static let wh1x1: HHSDKVideo.ZLImageClipRatio
  @objc public static let wh3x4: HHSDKVideo.ZLImageClipRatio
  @objc public static let wh4x3: HHSDKVideo.ZLImageClipRatio
  @objc public static let wh2x3: HHSDKVideo.ZLImageClipRatio
  @objc public static let wh3x2: HHSDKVideo.ZLImageClipRatio
  @objc public static let wh9x16: HHSDKVideo.ZLImageClipRatio
  @objc public static let wh16x9: HHSDKVideo.ZLImageClipRatio
}
@objc public class ZLEditImageModel : ObjectiveC.NSObject {
  final public let drawPaths: [HHSDKVideo.ZLDrawPath]
  final public let mosaicPaths: [HHSDKVideo.ZLMosaicPath]
  final public let editRect: CoreGraphics.CGRect?
  final public let angle: CoreGraphics.CGFloat
  final public let brightness: Swift.Float
  final public let contrast: Swift.Float
  final public let saturation: Swift.Float
  final public let selectRatio: HHSDKVideo.ZLImageClipRatio?
  final public let selectFilter: HHSDKVideo.ZLFilter?
  final public let textStickers: [(state: HHSDKVideo.ZLTextStickerState, index: Swift.Int)]?
  final public let imageStickers: [(state: HHSDKVideo.ZLImageStickerState, index: Swift.Int)]?
  public init(drawPaths: [HHSDKVideo.ZLDrawPath], mosaicPaths: [HHSDKVideo.ZLMosaicPath], editRect: CoreGraphics.CGRect?, angle: CoreGraphics.CGFloat, brightness: Swift.Float, contrast: Swift.Float, saturation: Swift.Float, selectRatio: HHSDKVideo.ZLImageClipRatio?, selectFilter: HHSDKVideo.ZLFilter, textStickers: [(state: HHSDKVideo.ZLTextStickerState, index: Swift.Int)]?, imageStickers: [(state: HHSDKVideo.ZLImageStickerState, index: Swift.Int)]?)
  @objc override dynamic public init()
  @objc deinit
}
@objc open class ZLEditImageViewController : UIKit.UIViewController {
  @objc public var drawColViewH: CoreGraphics.CGFloat
  @objc public var filterColViewH: CoreGraphics.CGFloat
  @objc public var adjustColViewH: CoreGraphics.CGFloat
  @objc public var ashbinNormalBgColor: UIKit.UIColor
  @objc public var cancelBtn: HHSDKVideo.ZLEnlargeButton {
    @objc get
    @objc set
  }
  @objc public var mainScrollView: UIKit.UIScrollView {
    @objc get
    @objc set
  }
  @objc public var topShadowView: UIKit.UIView {
    @objc get
    @objc set
  }
  @objc public var topShadowLayer: QuartzCore.CAGradientLayer {
    @objc get
    @objc set
  }
  @objc public var bottomShadowView: UIKit.UIView
  @objc public var bottomShadowLayer: QuartzCore.CAGradientLayer
  @objc public var doneBtn: UIKit.UIButton
  @objc public var revokeBtn: UIKit.UIButton
  @objc public var ashbinView: UIKit.UIView {
    @objc get
    @objc set
  }
  @objc public var ashbinImgView: UIKit.UIImageView {
    @objc get
    @objc set
  }
  @objc public var drawLineWidth: CoreGraphics.CGFloat
  @objc public var mosaicLineWidth: CoreGraphics.CGFloat
  @objc public var editFinishBlock: ((UIKit.UIImage, HHSDKVideo.ZLEditImageModel?) -> Swift.Void)?
  @objc public var cancelEditBlock: (() -> Swift.Void)?
  @objc override dynamic public var prefersStatusBarHidden: Swift.Bool {
    @objc get
  }
  @objc override dynamic public var supportedInterfaceOrientations: UIKit.UIInterfaceOrientationMask {
    @objc get
  }
  @objc deinit
  @objc public class func showEditImageVC(parentVC: UIKit.UIViewController?, animate: Swift.Bool = false, image: UIKit.UIImage, editModel: HHSDKVideo.ZLEditImageModel? = nil, cancel: (() -> Swift.Void)? = nil, completion: ((UIKit.UIImage, HHSDKVideo.ZLEditImageModel?) -> Swift.Void)?)
  @objc public init(image: UIKit.UIImage, editModel: HHSDKVideo.ZLEditImageModel? = nil)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc override dynamic open func viewDidLoad()
  @objc override dynamic open func viewDidLayoutSubviews()
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
}
extension ZLEditImageViewController : UIKit.UIGestureRecognizerDelegate {
  @objc dynamic public func gestureRecognizerShouldBegin(_ gestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
}
extension ZLEditImageViewController : UIKit.UIScrollViewDelegate {
  @objc dynamic public func viewForZooming(in scrollView: UIKit.UIScrollView) -> UIKit.UIView?
  @objc dynamic public func scrollViewDidZoom(_ scrollView: UIKit.UIScrollView)
  @objc dynamic public func scrollViewDidEndZooming(_ scrollView: UIKit.UIScrollView, with view: UIKit.UIView?, atScale scale: CoreGraphics.CGFloat)
  @objc dynamic public func scrollViewDidScroll(_ scrollView: UIKit.UIScrollView)
  @objc dynamic public func scrollViewDidEndDragging(_ scrollView: UIKit.UIScrollView, willDecelerate decelerate: Swift.Bool)
  @objc dynamic public func scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
  @objc dynamic public func scrollViewDidEndScrollingAnimation(_ scrollView: UIKit.UIScrollView)
}
extension ZLEditImageViewController : UIKit.UICollectionViewDataSource, UIKit.UICollectionViewDelegate {
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, didSelectItemAt indexPath: Foundation.IndexPath)
}
@objc @_hasMissingDesignatedInitializers public class ZLDrawPath : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers public class ZLMosaicPath : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers public class ZLEditVideoViewController : UIKit.UIViewController {
  @objc public var editFinishBlock: ((Foundation.URL?) -> Swift.Void)?
  @objc override dynamic public var prefersStatusBarHidden: Swift.Bool {
    @objc get
  }
  @objc override dynamic public var supportedInterfaceOrientations: UIKit.UIInterfaceOrientationMask {
    @objc get
  }
  @objc deinit
  @objc public init(avAsset: AVFoundation.AVAsset, animateDismiss: Swift.Bool = false)
  @objc override dynamic public func viewDidLoad()
  @objc override dynamic public func viewDidAppear(_ animated: Swift.Bool)
  @objc override dynamic public func viewDidLayoutSubviews()
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
}
extension ZLEditVideoViewController : UIKit.UIGestureRecognizerDelegate {
  @objc dynamic public func gestureRecognizerShouldBegin(_ gestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
}
extension ZLEditVideoViewController : UIKit.UICollectionViewDataSource, UIKit.UICollectionViewDelegateFlowLayout {
  @objc dynamic public func scrollViewDidScroll(_ scrollView: UIKit.UIScrollView)
  @objc dynamic public func scrollViewDidEndDragging(_ scrollView: UIKit.UIScrollView, willDecelerate decelerate: Swift.Bool)
  @objc dynamic public func scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, insetForSectionAt section: Swift.Int) -> UIKit.UIEdgeInsets
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, willDisplay cell: UIKit.UICollectionViewCell, forItemAt indexPath: Foundation.IndexPath)
}
@objc @_inheritsConvenienceInitializers public class ZLEnlargeButton : UIKit.UIButton {
  public var enlargeInsets: UIKit.UIEdgeInsets
  public var enlargeInset: CoreGraphics.CGFloat {
    get
    set
  }
  @objc override dynamic public func point(inside point: CoreGraphics.CGPoint, with event: UIKit.UIEvent?) -> Swift.Bool
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public typealias ZLFilterApplierType = ((UIKit.UIImage) -> UIKit.UIImage)
@objc public enum ZLFilterType : Swift.Int {
  case normal
  case chrome
  case fade
  case instant
  case process
  case transfer
  case tone
  case linear
  case sepia
  case mono
  case noir
  case tonal
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public class ZLFilter : ObjectiveC.NSObject {
  public var name: Swift.String
  @objc public init(name: Swift.String, filterType: HHSDKVideo.ZLFilterType)
  @objc public init(name: Swift.String, applier: HHSDKVideo.ZLFilterApplierType?)
  @objc override dynamic public init()
  @objc deinit
}
extension ZLFilter {
  @objc public static let all: [HHSDKVideo.ZLFilter]
  @objc public static let normal: HHSDKVideo.ZLFilter
  @objc public static let clarendon: HHSDKVideo.ZLFilter
  @objc public static let nashville: HHSDKVideo.ZLFilter
  @objc public static let apply1977: HHSDKVideo.ZLFilter
  @objc public static let toaster: HHSDKVideo.ZLFilter
  @objc public static let chrome: HHSDKVideo.ZLFilter
  @objc public static let fade: HHSDKVideo.ZLFilter
  @objc public static let instant: HHSDKVideo.ZLFilter
  @objc public static let process: HHSDKVideo.ZLFilter
  @objc public static let transfer: HHSDKVideo.ZLFilter
  @objc public static let tone: HHSDKVideo.ZLFilter
  @objc public static let linear: HHSDKVideo.ZLFilter
  @objc public static let sepia: HHSDKVideo.ZLFilter
  @objc public static let mono: HHSDKVideo.ZLFilter
  @objc public static let noir: HHSDKVideo.ZLFilter
  @objc public static let tonal: HHSDKVideo.ZLFilter
}
@objc public enum ZLURLType : Swift.Int {
  case image
  case video
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc @_hasMissingDesignatedInitializers public class ZLImagePreviewController : UIKit.UIViewController {
  @objc public var longPressBlock: ((HHSDKVideo.ZLImagePreviewController?, UIKit.UIImage?, Swift.Int) -> Swift.Void)?
  @objc public var doneBlock: (([Any]) -> Swift.Void)?
  @objc public var videoHttpHeader: [Swift.String : Any]?
  @objc override dynamic public var prefersStatusBarHidden: Swift.Bool {
    @objc get
  }
  @objc override dynamic public var preferredStatusBarStyle: UIKit.UIStatusBarStyle {
    @objc get
  }
  @objc public init(datas: [Any], index: Swift.Int = 0, showSelectBtn: Swift.Bool = true, showBottomView: Swift.Bool = true, urlType: ((Foundation.URL) -> HHSDKVideo.ZLURLType)? = nil, urlImageLoader: ((Foundation.URL, UIKit.UIImageView, @escaping (CoreGraphics.CGFloat) -> Swift.Void, @escaping () -> Swift.Void) -> Swift.Void)? = nil)
  @objc override dynamic public func viewDidLoad()
  @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @objc override dynamic public func viewDidAppear(_ animated: Swift.Bool)
  @objc override dynamic public func viewDidLayoutSubviews()
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc deinit
}
extension ZLImagePreviewController {
  @objc dynamic public func scrollViewDidScroll(_ scrollView: UIKit.UIScrollView)
  @objc dynamic public func scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
}
extension ZLImagePreviewController : UIKit.UICollectionViewDataSource, UIKit.UICollectionViewDelegateFlowLayout {
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, minimumInteritemSpacingForSectionAt section: Swift.Int) -> CoreGraphics.CGFloat
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, minimumLineSpacingForSectionAt section: Swift.Int) -> CoreGraphics.CGFloat
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, insetForSectionAt section: Swift.Int) -> UIKit.UIEdgeInsets
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, sizeForItemAt indexPath: Foundation.IndexPath) -> CoreGraphics.CGSize
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, didEndDisplaying cell: UIKit.UICollectionViewCell, forItemAt indexPath: Foundation.IndexPath)
}
@objc @_hasMissingDesignatedInitializers public class ZLImageStickerState : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
@objc public enum ZLLanguageType : Swift.Int {
  case system
  case chineseSimplified
  case chineseTraditional
  case english
  case japanese
  case french
  case german
  case russian
  case vietnamese
  case korean
  case malay
  case italian
  case indonesian
  case portuguese
  case spanish
  case turkish
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct ZLLocalLanguageKey : Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let previewCamera: HHSDKVideo.ZLLocalLanguageKey
  public static let previewCameraRecord: HHSDKVideo.ZLLocalLanguageKey
  public static let previewAlbum: HHSDKVideo.ZLLocalLanguageKey
  public static let cancel: HHSDKVideo.ZLLocalLanguageKey
  public static let noPhotoTips: HHSDKVideo.ZLLocalLanguageKey
  public static let loading: HHSDKVideo.ZLLocalLanguageKey
  public static let hudLoading: HHSDKVideo.ZLLocalLanguageKey
  public static let done: HHSDKVideo.ZLLocalLanguageKey
  public static let ok: HHSDKVideo.ZLLocalLanguageKey
  public static let timeout: HHSDKVideo.ZLLocalLanguageKey
  public static let noPhotoLibratyAuthority: HHSDKVideo.ZLLocalLanguageKey
  public static let noCameraAuthority: HHSDKVideo.ZLLocalLanguageKey
  public static let noMicrophoneAuthority: HHSDKVideo.ZLLocalLanguageKey
  public static let cameraUnavailable: HHSDKVideo.ZLLocalLanguageKey
  public static let keepRecording: HHSDKVideo.ZLLocalLanguageKey
  public static let gotoSettings: HHSDKVideo.ZLLocalLanguageKey
  public static let photo: HHSDKVideo.ZLLocalLanguageKey
  public static let originalPhoto: HHSDKVideo.ZLLocalLanguageKey
  public static let back: HHSDKVideo.ZLLocalLanguageKey
  public static let edit: HHSDKVideo.ZLLocalLanguageKey
  public static let editFinish: HHSDKVideo.ZLLocalLanguageKey
  public static let revert: HHSDKVideo.ZLLocalLanguageKey
  public static let brightness: HHSDKVideo.ZLLocalLanguageKey
  public static let contrast: HHSDKVideo.ZLLocalLanguageKey
  public static let saturation: HHSDKVideo.ZLLocalLanguageKey
  public static let preview: HHSDKVideo.ZLLocalLanguageKey
  public static let notAllowMixSelect: HHSDKVideo.ZLLocalLanguageKey
  public static let save: HHSDKVideo.ZLLocalLanguageKey
  public static let saveImageError: HHSDKVideo.ZLLocalLanguageKey
  public static let saveVideoError: HHSDKVideo.ZLLocalLanguageKey
  public static let exceededMaxSelectCount: HHSDKVideo.ZLLocalLanguageKey
  public static let exceededMaxVideoSelectCount: HHSDKVideo.ZLLocalLanguageKey
  public static let lessThanMinVideoSelectCount: HHSDKVideo.ZLLocalLanguageKey
  public static let longerThanMaxVideoDuration: HHSDKVideo.ZLLocalLanguageKey
  public static let shorterThanMaxVideoDuration: HHSDKVideo.ZLLocalLanguageKey
  public static let iCloudVideoLoadFaild: HHSDKVideo.ZLLocalLanguageKey
  public static let imageLoadFailed: HHSDKVideo.ZLLocalLanguageKey
  public static let customCameraTips: HHSDKVideo.ZLLocalLanguageKey
  public static let customCameraTakePhotoTips: HHSDKVideo.ZLLocalLanguageKey
  public static let customCameraRecordVideoTips: HHSDKVideo.ZLLocalLanguageKey
  public static let minRecordTimeTips: HHSDKVideo.ZLLocalLanguageKey
  public static let cameraRoll: HHSDKVideo.ZLLocalLanguageKey
  public static let panoramas: HHSDKVideo.ZLLocalLanguageKey
  public static let videos: HHSDKVideo.ZLLocalLanguageKey
  public static let favorites: HHSDKVideo.ZLLocalLanguageKey
  public static let timelapses: HHSDKVideo.ZLLocalLanguageKey
  public static let recentlyAdded: HHSDKVideo.ZLLocalLanguageKey
  public static let bursts: HHSDKVideo.ZLLocalLanguageKey
  public static let slomoVideos: HHSDKVideo.ZLLocalLanguageKey
  public static let selfPortraits: HHSDKVideo.ZLLocalLanguageKey
  public static let screenshots: HHSDKVideo.ZLLocalLanguageKey
  public static let depthEffect: HHSDKVideo.ZLLocalLanguageKey
  public static let livePhotos: HHSDKVideo.ZLLocalLanguageKey
  public static let animated: HHSDKVideo.ZLLocalLanguageKey
  public static let myPhotoStream: HHSDKVideo.ZLLocalLanguageKey
  public static let noTitleAlbumListPlaceholder: HHSDKVideo.ZLLocalLanguageKey
  public static let unableToAccessAllPhotos: HHSDKVideo.ZLLocalLanguageKey
  public static let textStickerRemoveTips: HHSDKVideo.ZLLocalLanguageKey
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: HHSDKVideo.ZLLocalLanguageKey, b: HHSDKVideo.ZLLocalLanguageKey) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public typealias Second = Swift.Int
@objc @_inheritsConvenienceInitializers public class ZLPhotoConfiguration : ObjectiveC.NSObject {
  @objc public class func `default`() -> HHSDKVideo.ZLPhotoConfiguration
  @objc public class func resetConfiguration()
  @objc public var sortAscending: Swift.Bool
  @objc public var maxSelectCount: Swift.Int {
    @objc get
    @objc set
  }
  @objc public var maxVideoSelectCount: Swift.Int {
    @objc get
    @objc set
  }
  @objc public var minVideoSelectCount: Swift.Int {
    @objc get
    @objc set
  }
  @objc public var allowMixSelect: Swift.Bool
  @objc public var maxPreviewCount: Swift.Int
  @objc public var cellCornerRadio: CoreGraphics.CGFloat
  @objc public var allowSelectImage: Swift.Bool
  @objc public var allowSelectVideo: Swift.Bool
  @objc public var allowSelectGif: Swift.Bool
  @objc public var allowSelectLivePhoto: Swift.Bool
  @objc public var allowTakePhotoInLibrary: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public var allowEditImage: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public var allowEditVideo: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public var animateSelectBtnWhenSelect: Swift.Bool
  @objc public var selectBtnAnimationDuration: Swift.Double
  @objc public var editAfterSelectThumbnailImage: Swift.Bool
  @objc public var cropVideoAfterSelectThumbnail: Swift.Bool
  @objc public var showClipDirectlyIfOnlyHasClipTool: Swift.Bool
  @objc public var saveNewImageAfterEdit: Swift.Bool
  @objc public var allowSlideSelect: Swift.Bool
  @objc public var autoScrollWhenSlideSelectIsActive: Swift.Bool
  @objc public var autoScrollMaxSpeed: CoreGraphics.CGFloat
  @objc public var allowDragSelect: Swift.Bool
  @objc public var allowSelectOriginal: Swift.Bool
  @objc public var allowPreviewPhotos: Swift.Bool
  @objc public var showPreviewButtonInAlbum: Swift.Bool
  @objc public var showSelectCountOnDoneBtn: Swift.Bool
  @objc public var columnCount: Swift.Int {
    @objc get
    @objc set
  }
  @objc public var maxEditVideoTime: Swift.Int
  @objc public var maxSelectVideoDuration: Swift.Int
  @objc public var minSelectVideoDuration: Swift.Int
  @objc public var editImageConfiguration: HHSDKVideo.ZLEditImageConfiguration
  @objc public var showCaptureImageOnTakePhotoBtn: Swift.Bool
  @objc public var showSelectBtnWhenSingleSelect: Swift.Bool
  @objc public var showSelectedMask: Swift.Bool
  @objc public var showSelectedBorder: Swift.Bool
  @objc public var showInvalidMask: Swift.Bool
  @objc public var showSelectedIndex: Swift.Bool
  @objc public var showSelectedPhotoPreview: Swift.Bool
  @objc public var shouldAnialysisAsset: Swift.Bool
  @objc public var timeout: Swift.Double
  @objc public var languageType: HHSDKVideo.ZLLanguageType {
    @objc get
    @objc set
  }
  @objc public var useCustomCamera: Swift.Bool
  @objc public var allowTakePhoto: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public var allowRecordVideo: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public var minRecordDuration: HHSDKVideo.Second {
    @objc get
    @objc set
  }
  @objc public var maxRecordDuration: HHSDKVideo.Second {
    @objc get
    @objc set
  }
  @objc public var cameraConfiguration: HHSDKVideo.ZLCameraConfiguration
  @objc public var hudStyle: HHSDKVideo.ZLProgressHUD.HUDStyle
  @objc public var canSelectAsset: ((Photos.PHAsset) -> Swift.Bool)?
  @objc public var showAddPhotoButton: Swift.Bool
  @objc public var showEnterSettingTips: Swift.Bool
  @objc public var noAuthorityCallback: ((HHSDKVideo.ZLNoAuthorityType) -> Swift.Void)?
  @objc public var operateBeforeDoneAction: ((UIKit.UIViewController, @escaping () -> Swift.Void) -> Swift.Void)?
  @objc override dynamic public init()
  @objc deinit
}
@objc public enum ZLNoAuthorityType : Swift.Int {
  case library
  case camera
  case microphone
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension ZLPhotoConfiguration {
  @discardableResult
  public func sortAscending(_ ascending: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func maxSelectCount(_ count: Swift.Int) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func maxVideoSelectCount(_ count: Swift.Int) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func minVideoSelectCount(_ count: Swift.Int) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func allowMixSelect(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func maxPreviewCount(_ count: Swift.Int) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func cellCornerRadio(_ cornerRadio: CoreGraphics.CGFloat) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func allowSelectImage(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  @objc dynamic public func allowSelectVideo(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func allowSelectGif(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func allowSelectLivePhoto(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func allowTakePhotoInLibrary(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func allowEditImage(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func allowEditVideo(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func animateSelectBtnWhenSelect(_ animate: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func selectBtnAnimationDuration(_ duration: CoreFoundation.CFTimeInterval) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func editAfterSelectThumbnailImage(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func cropVideoAfterSelectThumbnail(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func showClipDirectlyIfOnlyHasClipTool(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func saveNewImageAfterEdit(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func allowSlideSelect(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func autoScrollWhenSlideSelectIsActive(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func autoScrollMaxSpeed(_ speed: CoreGraphics.CGFloat) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func allowDragSelect(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func allowSelectOriginal(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func allowPreviewPhotos(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func showPreviewButtonInAlbum(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func showSelectCountOnDoneBtn(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func columnCount(_ count: Swift.Int) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func maxEditVideoTime(_ second: HHSDKVideo.Second) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func maxSelectVideoDuration(_ duration: HHSDKVideo.Second) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func minSelectVideoDuration(_ duration: HHSDKVideo.Second) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func editImageConfiguration(_ configuration: HHSDKVideo.ZLEditImageConfiguration) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func showCaptureImageOnTakePhotoBtn(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func showSelectBtnWhenSingleSelect(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func showSelectedMask(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func showSelectedBorder(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func showInvalidMask(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func showSelectedIndex(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func showSelectedPhotoPreview(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func shouldAnialysisAsset(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func timeout(_ timeout: Foundation.TimeInterval) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func languageType(_ type: HHSDKVideo.ZLLanguageType) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func useCustomCamera(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func allowTakePhoto(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func allowRecordVideo(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func minRecordDuration(_ duration: HHSDKVideo.Second) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func maxRecordDuration(_ duration: HHSDKVideo.Second) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func cameraConfiguration(_ configuration: HHSDKVideo.ZLCameraConfiguration) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  public func hudStyle(_ style: HHSDKVideo.ZLProgressHUD.HUDStyle) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  @objc dynamic public func canSelectAsset(_ block: ((Photos.PHAsset) -> Swift.Bool)?) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  @objc dynamic public func showAddPhotoButton(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  @objc dynamic public func showEnterSettingTips(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  @objc dynamic public func noAuthorityCallback(_ callback: ((HHSDKVideo.ZLNoAuthorityType) -> Swift.Void)?) -> HHSDKVideo.ZLPhotoConfiguration
  @discardableResult
  @objc dynamic public func operateBeforeDoneAction(_ block: ((UIKit.UIViewController, @escaping () -> Swift.Void) -> Swift.Void)?) -> HHSDKVideo.ZLPhotoConfiguration
}
@objc @_inheritsConvenienceInitializers public class ZLPhotoManager : ObjectiveC.NSObject {
  @objc public class func saveImageToAlbum(image: UIKit.UIImage, completion: ((Swift.Bool, Photos.PHAsset?) -> Swift.Void)?)
  @objc public class func saveVideoToAlbum(url: Foundation.URL, completion: ((Swift.Bool, Photos.PHAsset?) -> Swift.Void)?)
  @objc public class func fetchPhoto(in result: Photos.PHFetchResult<Photos.PHAsset>, ascending: Swift.Bool, allowSelectImage: Swift.Bool, allowSelectVideo: Swift.Bool, limitCount: Swift.Int = .max) -> [HHSDKVideo.ZLPhotoModel]
  @objc public class func getPhotoAlbumList(ascending: Swift.Bool, allowSelectImage: Swift.Bool, allowSelectVideo: Swift.Bool, completion: ([HHSDKVideo.ZLAlbumListModel]) -> Swift.Void)
  @objc public class func getCameraRollAlbum(allowSelectImage: Swift.Bool, allowSelectVideo: Swift.Bool, completion: @escaping (HHSDKVideo.ZLAlbumListModel) -> Swift.Void)
  @discardableResult
  @objc public class func fetchImage(for asset: Photos.PHAsset, size: CoreGraphics.CGSize, progress: ((CoreGraphics.CGFloat, Swift.Error?, Swift.UnsafeMutablePointer<ObjectiveC.ObjCBool>, [Swift.AnyHashable : Any]?) -> Swift.Void)? = nil, completion: @escaping (UIKit.UIImage?, Swift.Bool) -> Swift.Void) -> Photos.PHImageRequestID
  @discardableResult
  @objc public class func fetchOriginalImage(for asset: Photos.PHAsset, progress: ((CoreGraphics.CGFloat, Swift.Error?, Swift.UnsafeMutablePointer<ObjectiveC.ObjCBool>, [Swift.AnyHashable : Any]?) -> Swift.Void)? = nil, completion: @escaping (UIKit.UIImage?, Swift.Bool) -> Swift.Void) -> Photos.PHImageRequestID
  @discardableResult
  @objc public class func fetchOriginalImageData(for asset: Photos.PHAsset, progress: ((CoreGraphics.CGFloat, Swift.Error?, Swift.UnsafeMutablePointer<ObjectiveC.ObjCBool>, [Swift.AnyHashable : Any]?) -> Swift.Void)? = nil, completion: @escaping (Foundation.Data, [Swift.AnyHashable : Any]?, Swift.Bool) -> Swift.Void) -> Photos.PHImageRequestID
  @objc public class func fetchLivePhoto(for asset: Photos.PHAsset, completion: @escaping (Photos.PHLivePhoto?, [Swift.AnyHashable : Any]?, Swift.Bool) -> Swift.Void) -> Photos.PHImageRequestID
  @objc public class func fetchVideo(for asset: Photos.PHAsset, progress: ((CoreGraphics.CGFloat, Swift.Error?, Swift.UnsafeMutablePointer<ObjectiveC.ObjCBool>, [Swift.AnyHashable : Any]?) -> Swift.Void)? = nil, completion: @escaping (AVFoundation.AVPlayerItem?, [Swift.AnyHashable : Any]?, Swift.Bool) -> Swift.Void) -> Photos.PHImageRequestID
  @objc public class func fetchAVAsset(forVideo asset: Photos.PHAsset, completion: @escaping (AVFoundation.AVAsset?, [Swift.AnyHashable : Any]?) -> Swift.Void) -> Photos.PHImageRequestID
  @objc public class func fetchAssetFilePath(asset: Photos.PHAsset, completion: @escaping (Swift.String?) -> Swift.Void)
  @objc override dynamic public init()
  @objc deinit
}
extension ZLPhotoManager {
  @objc dynamic public class func hasPhotoLibratyAuthority() -> Swift.Bool
  @objc dynamic public class func hasCameraAuthority() -> Swift.Bool
  @objc dynamic public class func hasMicrophoneAuthority() -> Swift.Bool
}
extension ZLPhotoModel {
  public enum MediaType : Swift.Int {
    case unknown
    case image
    case gif
    case livePhoto
    case video
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
@objc public class ZLPhotoModel : ObjectiveC.NSObject {
  final public let ident: Swift.String
  final public let asset: Photos.PHAsset
  public var type: HHSDKVideo.ZLPhotoModel.MediaType
  public var duration: Swift.String
  public var isSelected: Swift.Bool
  public var editImage: UIKit.UIImage? {
    get
    set
  }
  public var second: HHSDKVideo.Second {
    get
  }
  public var whRatio: CoreGraphics.CGFloat {
    get
  }
  public var previewSize: CoreGraphics.CGSize {
    get
  }
  public var editImageModel: HHSDKVideo.ZLEditImageModel?
  public init(asset: Photos.PHAsset)
  public func transformAssetType(for asset: Photos.PHAsset) -> HHSDKVideo.ZLPhotoModel.MediaType
  public func transformDuration(for asset: Photos.PHAsset) -> Swift.String
  @objc override dynamic public init()
  @objc deinit
}
extension ZLPhotoModel {
  public static func == (lhs: HHSDKVideo.ZLPhotoModel, rhs: HHSDKVideo.ZLPhotoModel) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers public class ZLPhotoPreviewSheet : UIKit.UIView {
  @objc public var selectImageBlock: (([HHSDKVideo.HHPhotoPickerModel], Swift.Bool) -> Swift.Void)?
  @objc public var selectImageRequestErrorBlock: (([Photos.PHAsset], [Swift.Int]) -> Swift.Void)?
  @objc public var cancelBlock: (() -> Swift.Void)?
  @objc deinit
  @objc convenience override dynamic public init(frame: CoreGraphics.CGRect)
  @objc public init(selectedAssets: [Photos.PHAsset]? = nil)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc override dynamic public func layoutSubviews()
  @objc public func showPreview(animate: Swift.Bool = true, sender: UIKit.UIViewController)
  @objc public func showPhotoLibrary(sender: UIKit.UIViewController)
  @objc public func previewAssets(sender: UIKit.UIViewController, assets: [Photos.PHAsset], index: Swift.Int, isOriginal: Swift.Bool, showBottomViewAndSelectBtn: Swift.Bool = true)
}
extension ZLPhotoPreviewSheet : UIKit.UIGestureRecognizerDelegate {
  @objc override dynamic public func gestureRecognizerShouldBegin(_ gestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
}
extension ZLPhotoPreviewSheet : UIKit.UICollectionViewDataSource, UIKit.UICollectionViewDelegateFlowLayout {
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, sizeForItemAt indexPath: Foundation.IndexPath) -> CoreGraphics.CGSize
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, willDisplay cell: UIKit.UICollectionViewCell, forItemAt indexPath: Foundation.IndexPath)
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, didSelectItemAt indexPath: Foundation.IndexPath)
}
extension ZLPhotoPreviewSheet : UIKit.UIImagePickerControllerDelegate, UIKit.UINavigationControllerDelegate {
  @objc dynamic public func imagePickerController(_ picker: UIKit.UIImagePickerController, didFinishPickingMediaWithInfo info: [UIKit.UIImagePickerController.InfoKey : Any])
}
extension ZLPhotoPreviewSheet : Photos.PHPhotoLibraryChangeObserver {
  @objc dynamic public func photoLibraryDidChange(_ changeInstance: Photos.PHChange)
}
@objc @_inheritsConvenienceInitializers public class ZLPhotoUIConfiguration : ObjectiveC.NSObject {
  @objc public enum CancelButtonStyle : Swift.Int {
    case text
    case image
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc public class func `default`() -> HHSDKVideo.ZLPhotoUIConfiguration
  @objc public class func resetConfiguration()
  @objc public var style: HHSDKVideo.ZLPhotoBrowserStyle
  @objc public var statusBarStyle: UIKit.UIStatusBarStyle
  @objc public var navCancelButtonStyle: HHSDKVideo.ZLPhotoUIConfiguration.CancelButtonStyle
  @objc public var showStatusBarInPreviewInterface: Swift.Bool
  @objc public var navViewBlurEffectOfAlbumList: UIKit.UIBlurEffect?
  @objc public var navViewBlurEffectOfPreview: UIKit.UIBlurEffect?
  @objc public var bottomViewBlurEffectOfAlbumList: UIKit.UIBlurEffect?
  @objc public var bottomViewBlurEffectOfPreview: UIKit.UIBlurEffect?
  @objc public var customImageNames: [Swift.String] {
    @objc get
    @objc set
  }
  public var customImageForKey: [Swift.String : UIKit.UIImage?] {
    get
    set
  }
  @objc public var customImageForKey_objc: [Swift.String : UIKit.UIImage] {
    @objc get
    @objc set
  }
  public var customLanguageKeyValue: [HHSDKVideo.ZLLocalLanguageKey : Swift.String] {
    get
    set
  }
  @objc public var customLanguageKeyValue_objc: [Swift.String : Swift.String] {
    @objc get
    @objc set
  }
  @objc public var themeFontName: Swift.String? {
    @objc get
    @objc set
  }
  @objc public var sheetTranslucentColor: UIKit.UIColor
  @objc public var sheetBtnBgColor: UIKit.UIColor
  @objc public var sheetBtnTitleColor: UIKit.UIColor
  @objc public var sheetBtnTitleTintColor: UIKit.UIColor
  @objc public var navBarColor: UIKit.UIColor
  @objc public var navBarColorOfPreviewVC: UIKit.UIColor
  @objc public var navTitleColor: UIKit.UIColor
  @objc public var navTitleColorOfPreviewVC: UIKit.UIColor
  @objc public var navEmbedTitleViewBgColor: UIKit.UIColor
  @objc public var albumListBgColor: UIKit.UIColor
  @objc public var embedAlbumListTranslucentColor: UIKit.UIColor
  @objc public var albumListTitleColor: UIKit.UIColor
  @objc public var albumListCountColor: UIKit.UIColor
  @objc public var separatorColor: UIKit.UIColor
  @objc public var thumbnailBgColor: UIKit.UIColor
  @objc public var previewVCBgColor: UIKit.UIColor
  @objc public var bottomToolViewBgColor: UIKit.UIColor
  @objc public var bottomToolViewBgColorOfPreviewVC: UIKit.UIColor
  @objc public var bottomToolViewBtnNormalTitleColor: UIKit.UIColor
  @objc public var bottomToolViewDoneBtnNormalTitleColor: UIKit.UIColor
  @objc public var bottomToolViewBtnNormalTitleColorOfPreviewVC: UIKit.UIColor
  @objc public var bottomToolViewDoneBtnNormalTitleColorOfPreviewVC: UIKit.UIColor
  @objc public var bottomToolViewBtnDisableTitleColor: UIKit.UIColor
  @objc public var bottomToolViewDoneBtnDisableTitleColor: UIKit.UIColor
  @objc public var bottomToolViewBtnDisableTitleColorOfPreviewVC: UIKit.UIColor
  @objc public var bottomToolViewDoneBtnDisableTitleColorOfPreviewVC: UIKit.UIColor
  @objc public var bottomToolViewBtnNormalBgColor: UIKit.UIColor
  @objc public var bottomToolViewBtnNormalBgColorOfPreviewVC: UIKit.UIColor
  @objc public var bottomToolViewBtnDisableBgColor: UIKit.UIColor
  @objc public var bottomToolViewBtnDisableBgColorOfPreviewVC: UIKit.UIColor
  @objc public var selectMorePhotoWhenAuthIsLismitedTitleColor: UIKit.UIColor
  @objc public var cameraRecodeProgressColor: UIKit.UIColor
  @objc public var selectedMaskColor: UIKit.UIColor
  @objc public var selectedBorderColor: UIKit.UIColor
  @objc public var invalidMaskColor: UIKit.UIColor
  @objc public var indexLabelTextColor: UIKit.UIColor
  @objc public var indexLabelBgColor: UIKit.UIColor
  @objc public var cameraCellBgColor: UIKit.UIColor
  @objc public var adjustSliderNormalColor: UIKit.UIColor
  @objc public var adjustSliderTintColor: UIKit.UIColor
  @objc override dynamic public init()
  @objc deinit
}
@objc public enum ZLPhotoBrowserStyle : Swift.Int {
  case embedAlbumList
  case externalAlbumList
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension ZLPhotoUIConfiguration {
  @discardableResult
  public func style(_ style: HHSDKVideo.ZLPhotoBrowserStyle) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func statusBarStyle(_ statusBarStyle: UIKit.UIStatusBarStyle) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func navCancelButtonStyle(_ style: HHSDKVideo.ZLPhotoUIConfiguration.CancelButtonStyle) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func showStatusBarInPreviewInterface(_ value: Swift.Bool) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func navViewBlurEffectOfAlbumList(_ effect: UIKit.UIBlurEffect?) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func navViewBlurEffectOfPreview(_ effect: UIKit.UIBlurEffect?) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func bottomViewBlurEffectOfAlbumList(_ effect: UIKit.UIBlurEffect?) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func bottomViewBlurEffectOfPreview(_ effect: UIKit.UIBlurEffect?) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func customImageNames(_ names: [Swift.String]) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func customImageForKey(_ map: [Swift.String : UIKit.UIImage?]) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func customLanguageKeyValue(_ map: [HHSDKVideo.ZLLocalLanguageKey : Swift.String]) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func themeFontName(_ name: Swift.String) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func sheetTranslucentColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func sheetBtnBgColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func sheetBtnTitleColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func sheetBtnTitleTintColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func navBarColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func navBarColorOfPreviewVC(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func navTitleColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func navTitleColorOfPreviewVC(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func navEmbedTitleViewBgColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func albumListBgColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func embedAlbumListTranslucentColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func albumListTitleColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func albumListCountColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func separatorColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func thumbnailBgColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func previewVCBgColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func bottomToolViewBgColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func bottomToolViewBgColorOfPreviewVC(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func bottomToolViewBtnNormalTitleColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func bottomToolViewDoneBtnNormalTitleColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func bottomToolViewBtnNormalTitleColorOfPreviewVC(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func bottomToolViewDoneBtnNormalTitleColorOfPreviewVC(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func bottomToolViewBtnDisableTitleColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func bottomToolViewDoneBtnDisableTitleColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func bottomToolViewBtnDisableTitleColorOfPreviewVC(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func bottomToolViewDoneBtnDisableTitleColorOfPreviewVC(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func bottomToolViewBtnNormalBgColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func bottomToolViewBtnNormalBgColorOfPreviewVC(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func bottomToolViewBtnDisableBgColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func bottomToolViewBtnDisableBgColorOfPreviewVC(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func selectMorePhotoWhenAuthIsLismitedTitleColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func cameraRecodeProgressColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func selectedMaskColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func selectedBorderColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func invalidMaskColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func indexLabelTextColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func indexLabelBgColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func cameraCellBgColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func adjustSliderNormalColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
  @discardableResult
  public func adjustSliderTintColor(_ color: UIKit.UIColor) -> HHSDKVideo.ZLPhotoUIConfiguration
}
@objc @_hasMissingDesignatedInitializers public class ZLProgressHUD : UIKit.UIView {
  @objc public enum HUDStyle : Swift.Int {
    case light
    case lightBlur
    case dark
    case darkBlur
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc deinit
  @objc public init(style: HHSDKVideo.ZLProgressHUD.HUDStyle)
  @objc public func show(timeout: Foundation.TimeInterval = 100)
  @objc public func hide()
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
}
@objc @_hasMissingDesignatedInitializers public class ZLTextStickerState : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class ZLVideoManager : ObjectiveC.NSObject {
  @objc public class func mergeVideos(fileUrls: [Foundation.URL], completion: @escaping ((Foundation.URL?, Swift.Error?) -> Swift.Void))
  @objc override dynamic public init()
  @objc deinit
}
extension ZLVideoManager {
  @objc dynamic public class func exportVideo(for asset: Photos.PHAsset, exportType: HHSDKVideo.ZLVideoManager.ExportType = .mov, presetName: Swift.String = AVAssetExportPreset1920x1080, complete: @escaping ((Foundation.URL?, Swift.Error?) -> Swift.Void))
  @objc dynamic public class func exportVideo(for asset: AVFoundation.AVAsset, range: CoreMedia.CMTimeRange = CMTimeRange(start: .zero, duration: .positiveInfinity), exportType: HHSDKVideo.ZLVideoManager.ExportType = .mov, presetName: Swift.String = AVAssetExportPresetMediumQuality, complete: @escaping ((Foundation.URL?, Swift.Error?) -> Swift.Void))
}
extension ZLVideoManager {
  @objc public enum ExportType : Swift.Int {
    case mov
    case mp4
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension HHSDKVideo.AES.Error : Swift.Equatable {}
extension HHSDKVideo.AES.Error : Swift.Hashable {}
extension HHSDKVideo.AES.Variant : Swift.Equatable {}
extension HHSDKVideo.AES.Variant : Swift.Hashable {}
extension HHSDKVideo.AES.Variant : Swift.RawRepresentable {}
extension HHSDKVideo.Bit : Swift.Equatable {}
extension HHSDKVideo.Bit : Swift.Hashable {}
extension HHSDKVideo.Bit : Swift.RawRepresentable {}
extension HHSDKVideo.Blowfish.Error : Swift.Equatable {}
extension HHSDKVideo.Blowfish.Error : Swift.Hashable {}
extension HHSDKVideo.CBC.Error : Swift.Equatable {}
extension HHSDKVideo.CBC.Error : Swift.Hashable {}
extension HHSDKVideo.CCM : HHSDKVideo.BlockMode {}
extension HHSDKVideo.CCM.Error : Swift.Equatable {}
extension HHSDKVideo.CCM.Error : Swift.Hashable {}
extension HHSDKVideo.CFB.Error : Swift.Equatable {}
extension HHSDKVideo.CFB.Error : Swift.Hashable {}
extension HHSDKVideo.ChaCha20.Error : Swift.Equatable {}
extension HHSDKVideo.ChaCha20.Error : Swift.Hashable {}
extension HHSDKVideo.CipherError : Swift.Equatable {}
extension HHSDKVideo.CipherError : Swift.Hashable {}
extension HHSDKVideo.CMAC.Error : Swift.Equatable {}
extension HHSDKVideo.CMAC.Error : Swift.Hashable {}
extension HHSDKVideo.CTR : HHSDKVideo.BlockMode {}
extension HHSDKVideo.CTR.Error : Swift.Equatable {}
extension HHSDKVideo.CTR.Error : Swift.Hashable {}
extension HHSDKVideo.DateTransform.Unit : Swift.Equatable {}
extension HHSDKVideo.DateTransform.Unit : Swift.Hashable {}
extension HHSDKVideo.DateTransform.Unit : Swift.RawRepresentable {}
extension HHSDKVideo.DGElasticPullToRefreshState : Swift.Equatable {}
extension HHSDKVideo.DGElasticPullToRefreshState : Swift.Hashable {}
extension HHSDKVideo.DGElasticPullToRefreshState : Swift.RawRepresentable {}
extension HHSDKVideo.EKAlertMessage.ImagePosition : Swift.Equatable {}
extension HHSDKVideo.EKAlertMessage.ImagePosition : Swift.Hashable {}
extension HHSDKVideo.EKAttributes.Animation.Translate.AnchorPosition : Swift.Hashable {}
extension HHSDKVideo.EKAttributes.DisplayMode : Swift.Equatable {}
extension HHSDKVideo.EKAttributes.DisplayMode : Swift.Hashable {}
extension HHSDKVideo.EKAttributes.NotificationHapticFeedback : Swift.Equatable {}
extension HHSDKVideo.EKAttributes.NotificationHapticFeedback : Swift.Hashable {}
extension HHSDKVideo.EKAttributes.Position : Swift.Equatable {}
extension HHSDKVideo.EKAttributes.Position : Swift.Hashable {}
extension HHSDKVideo.EKAttributes.PositionConstraints.Rotation.SupportedInterfaceOrientation : Swift.Equatable {}
extension HHSDKVideo.EKAttributes.PositionConstraints.Rotation.SupportedInterfaceOrientation : Swift.Hashable {}
extension HHSDKVideo.EKAttributes.Precedence.QueueingHeuristic : Swift.Equatable {}
extension HHSDKVideo.EKAttributes.Precedence.QueueingHeuristic : Swift.Hashable {}
extension HHSDKVideo.EKAttributes.StatusBar : Swift.Equatable {}
extension HHSDKVideo.EKAttributes.StatusBar : Swift.Hashable {}
extension HHSDKVideo.GCM.Mode : Swift.Equatable {}
extension HHSDKVideo.GCM.Mode : Swift.Hashable {}
extension HHSDKVideo.GCM.Error : Swift.Equatable {}
extension HHSDKVideo.GCM.Error : Swift.Hashable {}
extension HHSDKVideo.HHHostType : Swift.Equatable {}
extension HHSDKVideo.HHHostType : Swift.Hashable {}
extension HHSDKVideo.HHBaseCallingState : Swift.Equatable {}
extension HHSDKVideo.HHBaseCallingState : Swift.Hashable {}
extension HHSDKVideo.HHBaseCallingState : Swift.RawRepresentable {}
extension HHSDKVideo.HHMediaType : Swift.Equatable {}
extension HHSDKVideo.HHMediaType : Swift.Hashable {}
extension HHSDKVideo.HHMediaType : Swift.RawRepresentable {}
extension HHSDKVideo.DateFormat : Swift.Equatable {}
extension HHSDKVideo.DateFormat : Swift.Hashable {}
extension HHSDKVideo.DateFormat : Swift.RawRepresentable {}
extension HHSDKVideo.HHConsType : Swift.Equatable {}
extension HHSDKVideo.HHConsType : Swift.Hashable {}
extension HHSDKVideo.HHConsType : Swift.RawRepresentable {}
extension HHSDKVideo.HHFileCacheManager.HHAssetPathType : Swift.Equatable {}
extension HHSDKVideo.HHFileCacheManager.HHAssetPathType : Swift.Hashable {}
extension HHSDKVideo.HHFileCacheManager.HHFileFormat : Swift.Equatable {}
extension HHSDKVideo.HHFileCacheManager.HHFileFormat : Swift.Hashable {}
extension HHSDKVideo.HHFileCacheManager.HHFileFormat : Swift.RawRepresentable {}
extension HHSDKVideo.HHLogMode : Swift.Equatable {}
extension HHSDKVideo.HHLogMode : Swift.Hashable {}
extension HHSDKVideo.HHLogMode : Swift.RawRepresentable {}
extension HHSDKVideo.HHCallType : Swift.Equatable {}
extension HHSDKVideo.HHCallType : Swift.Hashable {}
extension HHSDKVideo.HHCallType : Swift.RawRepresentable {}
extension HHSDKVideo.HHServerType : Swift.Equatable {}
extension HHSDKVideo.HHServerType : Swift.Hashable {}
extension HHSDKVideo.HHRequestMethod : Swift.Equatable {}
extension HHSDKVideo.HHRequestMethod : Swift.Hashable {}
extension HHSDKVideo.HHPagerViewTransformerType : Swift.Equatable {}
extension HHSDKVideo.HHPagerViewTransformerType : Swift.Hashable {}
extension HHSDKVideo.HHPagerViewTransformerType : Swift.RawRepresentable {}
extension HHSDKVideo.HHRealNameType : Swift.Equatable {}
extension HHSDKVideo.HHRealNameType : Swift.Hashable {}
extension HHSDKVideo.HHRealNameType : Swift.RawRepresentable {}
extension HHSDKVideo.TrtcLog : Swift.Equatable {}
extension HHSDKVideo.TrtcLog : Swift.Hashable {}
extension HHSDKVideo.TrtcLog : Swift.RawRepresentable {}
extension HHSDKVideo.TrtcError : Swift.Equatable {}
extension HHSDKVideo.TrtcError : Swift.Hashable {}
extension HHSDKVideo.TrtcError : Swift.RawRepresentable {}
extension HHSDKVideo.hhToastPosition : Swift.Equatable {}
extension HHSDKVideo.hhToastPosition : Swift.Hashable {}
extension HHSDKVideo.HKDF.Error : Swift.Equatable {}
extension HHSDKVideo.HKDF.Error : Swift.Hashable {}
extension HHSDKVideo.HMAC.Error : Swift.Equatable {}
extension HHSDKVideo.HMAC.Error : Swift.Hashable {}
extension HHSDKVideo.HMAC.Variant : Swift.Equatable {}
extension HHSDKVideo.HMAC.Variant : Swift.Hashable {}
extension HHSDKVideo.ItemClass : Swift.Equatable {}
extension HHSDKVideo.ItemClass : Swift.Hashable {}
extension HHSDKVideo.ProtocolType : Swift.Equatable {}
extension HHSDKVideo.ProtocolType : Swift.Hashable {}
extension HHSDKVideo.AuthenticationType : Swift.Equatable {}
extension HHSDKVideo.AuthenticationType : Swift.Hashable {}
extension HHSDKVideo.Accessibility : Swift.Equatable {}
extension HHSDKVideo.Accessibility : Swift.Hashable {}
extension HHSDKVideo.Status : Swift.Equatable {}
extension HHSDKVideo.Status : Swift.Hashable {}
extension HHSDKVideo.MappingType : Swift.Equatable {}
extension HHSDKVideo.MappingType : Swift.Hashable {}
extension HHSDKVideo.OCB.Mode : Swift.Equatable {}
extension HHSDKVideo.OCB.Mode : Swift.Hashable {}
extension HHSDKVideo.OCB.Error : Swift.Equatable {}
extension HHSDKVideo.OCB.Error : Swift.Hashable {}
extension HHSDKVideo.OFB.Error : Swift.Equatable {}
extension HHSDKVideo.OFB.Error : Swift.Hashable {}
extension HHSDKVideo.Padding : Swift.Equatable {}
extension HHSDKVideo.Padding : Swift.Hashable {}
extension HHSDKVideo.PKCS5.PBKDF1.Error : Swift.Equatable {}
extension HHSDKVideo.PKCS5.PBKDF1.Error : Swift.Hashable {}
extension HHSDKVideo.PKCS5.PBKDF1.Variant : Swift.Equatable {}
extension HHSDKVideo.PKCS5.PBKDF1.Variant : Swift.Hashable {}
extension HHSDKVideo.PKCS5.PBKDF2.Error : Swift.Equatable {}
extension HHSDKVideo.PKCS5.PBKDF2.Error : Swift.Hashable {}
extension HHSDKVideo.PCBC.Error : Swift.Equatable {}
extension HHSDKVideo.PCBC.Error : Swift.Hashable {}
extension HHSDKVideo.PermissionStatus : Swift.Equatable {}
extension HHSDKVideo.PermissionStatus : Swift.Hashable {}
extension HHSDKVideo.PermissionStatus : Swift.RawRepresentable {}
extension HHSDKVideo.HHBasePermissionType : Swift.Equatable {}
extension HHSDKVideo.HHBasePermissionType : Swift.Hashable {}
extension HHSDKVideo.HHBasePermissionType : Swift.RawRepresentable {}
extension HHSDKVideo.Poly1305.Error : Swift.Equatable {}
extension HHSDKVideo.Poly1305.Error : Swift.Hashable {}
extension HHSDKVideo.Rabbit.Error : Swift.Equatable {}
extension HHSDKVideo.Rabbit.Error : Swift.Hashable {}
extension HHSDKVideo.Reachability.NetworkStatus : Swift.Equatable {}
extension HHSDKVideo.Reachability.NetworkStatus : Swift.Hashable {}
extension HHSDKVideo.RecordImgType : Swift.Equatable {}
extension HHSDKVideo.RecordImgType : Swift.Hashable {}
extension HHSDKVideo.RecordImgType : Swift.RawRepresentable {}
extension HHSDKVideo.SHA2.Variant : Swift.Equatable {}
extension HHSDKVideo.SHA2.Variant : Swift.Hashable {}
extension HHSDKVideo.SHA3.Variant : Swift.Equatable {}
extension HHSDKVideo.SHA3.Variant : Swift.Hashable {}
extension HHSDKVideo.HHIMCmd : Swift.Equatable {}
extension HHSDKVideo.HHIMCmd : Swift.Hashable {}
extension HHSDKVideo.HHIMCmd : Swift.RawRepresentable {}
extension HHSDKVideo.ZLCameraConfiguration.CaptureSessionPreset : Swift.Equatable {}
extension HHSDKVideo.ZLCameraConfiguration.CaptureSessionPreset : Swift.Hashable {}
extension HHSDKVideo.ZLCameraConfiguration.CaptureSessionPreset : Swift.RawRepresentable {}
extension HHSDKVideo.ZLCameraConfiguration.FocusMode : Swift.Equatable {}
extension HHSDKVideo.ZLCameraConfiguration.FocusMode : Swift.Hashable {}
extension HHSDKVideo.ZLCameraConfiguration.FocusMode : Swift.RawRepresentable {}
extension HHSDKVideo.ZLCameraConfiguration.ExposureMode : Swift.Equatable {}
extension HHSDKVideo.ZLCameraConfiguration.ExposureMode : Swift.Hashable {}
extension HHSDKVideo.ZLCameraConfiguration.ExposureMode : Swift.RawRepresentable {}
extension HHSDKVideo.ZLCameraConfiguration.FlashMode : Swift.Equatable {}
extension HHSDKVideo.ZLCameraConfiguration.FlashMode : Swift.Hashable {}
extension HHSDKVideo.ZLCameraConfiguration.FlashMode : Swift.RawRepresentable {}
extension HHSDKVideo.ZLCameraConfiguration.VideoExportType : Swift.Equatable {}
extension HHSDKVideo.ZLCameraConfiguration.VideoExportType : Swift.Hashable {}
extension HHSDKVideo.ZLCameraConfiguration.VideoExportType : Swift.RawRepresentable {}
extension HHSDKVideo.ZLEditImageConfiguration.EditTool : Swift.Equatable {}
extension HHSDKVideo.ZLEditImageConfiguration.EditTool : Swift.Hashable {}
extension HHSDKVideo.ZLEditImageConfiguration.EditTool : Swift.RawRepresentable {}
extension HHSDKVideo.ZLEditImageConfiguration.AdjustTool : Swift.Equatable {}
extension HHSDKVideo.ZLEditImageConfiguration.AdjustTool : Swift.Hashable {}
extension HHSDKVideo.ZLEditImageConfiguration.AdjustTool : Swift.RawRepresentable {}
extension HHSDKVideo.ZLFilterType : Swift.Equatable {}
extension HHSDKVideo.ZLFilterType : Swift.Hashable {}
extension HHSDKVideo.ZLFilterType : Swift.RawRepresentable {}
extension HHSDKVideo.ZLURLType : Swift.Equatable {}
extension HHSDKVideo.ZLURLType : Swift.Hashable {}
extension HHSDKVideo.ZLURLType : Swift.RawRepresentable {}
extension HHSDKVideo.ZLLanguageType : Swift.Equatable {}
extension HHSDKVideo.ZLLanguageType : Swift.Hashable {}
extension HHSDKVideo.ZLLanguageType : Swift.RawRepresentable {}
extension HHSDKVideo.ZLNoAuthorityType : Swift.Equatable {}
extension HHSDKVideo.ZLNoAuthorityType : Swift.Hashable {}
extension HHSDKVideo.ZLNoAuthorityType : Swift.RawRepresentable {}
extension HHSDKVideo.ZLPhotoModel.MediaType : Swift.Equatable {}
extension HHSDKVideo.ZLPhotoModel.MediaType : Swift.Hashable {}
extension HHSDKVideo.ZLPhotoModel.MediaType : Swift.RawRepresentable {}
extension HHSDKVideo.ZLPhotoUIConfiguration.CancelButtonStyle : Swift.Equatable {}
extension HHSDKVideo.ZLPhotoUIConfiguration.CancelButtonStyle : Swift.Hashable {}
extension HHSDKVideo.ZLPhotoUIConfiguration.CancelButtonStyle : Swift.RawRepresentable {}
extension HHSDKVideo.ZLPhotoBrowserStyle : Swift.Equatable {}
extension HHSDKVideo.ZLPhotoBrowserStyle : Swift.Hashable {}
extension HHSDKVideo.ZLPhotoBrowserStyle : Swift.RawRepresentable {}
extension HHSDKVideo.ZLProgressHUD.HUDStyle : Swift.Equatable {}
extension HHSDKVideo.ZLProgressHUD.HUDStyle : Swift.Hashable {}
extension HHSDKVideo.ZLProgressHUD.HUDStyle : Swift.RawRepresentable {}
extension HHSDKVideo.ZLVideoManager.ExportType : Swift.Equatable {}
extension HHSDKVideo.ZLVideoManager.ExportType : Swift.Hashable {}
extension HHSDKVideo.ZLVideoManager.ExportType : Swift.RawRepresentable {}
